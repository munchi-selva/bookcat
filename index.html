<!DOCTYPE html>
<html>
    <head>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.css"/>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>

        <link rel="stylesheet" href="https://unpkg.com/ag-grid-enterprise/dist/styles/ag-grid.css">
        <link rel="stylesheet" href="https://unpkg.com/ag-grid-enterprise/dist/styles/ag-theme-balham.css">
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
        <script src="https://unpkg.com/@ag-grid-enterprise/all-modules/dist/ag-grid-enterprise.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
        <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

        <link rel="stylesheet" href="bookcat.css">
        <link rel="stylesheet" href="bookcat_comp.css">
        <script type="text/javascript" src="bookcat_comp.js"></script>
        <script type="text/javascript" src="bookcat_utils.js"></script>
    </head>
    <body>
        <div id="catGrid" class="cat-main-div ag-theme-balham container-fluid">
            <h2>Ex libris ... munchi</h2>
            <div class="panel-group">
                <div id="divCatInfo" class="cat-info"></div>
                <div class="cat-info-panel-heading">
                    <!-- Click to show/hide catalogue file selection and editing options -->
                    <a data-toggle="collapse" href="#divCatSelectForm">Catalogue file options</a>
                </div>
                <div id="divCatSelectForm" class="cat-info-panel-collapse collapse">
                    <div class="panel-body">
                        <form id="catDataForm" class="form-inline">
                            <span style="padding:0em 1em 0em 0em;">
                                <button type="button" id="btnNew" class="btn btn-primary">Create new catalogue</button>
                            </span>
                            <button type="button" id="btnLoadDefault" class="btn btn-primary">Load default catalogue</button>
                            <span style="padding:0em 2em;">
                                <input type="file" id="fileinputCat" class="form-control">
                                <button type="button" id="btnLoad" class="btn btn-primary">Load catalogue</button>
                            </span>
                            <button type="button" id="btnProcessUpdates" class="btn btn-primary">Save updated catalogue</button>
                        </form>
                        <hr/>
                    </div>
                </div>
            </div>
            <div class="cat-settings">
                <div class="form-check-inline">
                    <label class="form-check-label">Data source:</label>
                </div>
                <div class="form-check-inline">
                    <label class="form-check-label" for="srcComb">
                        <input type="radio" class="form-check-input" id="srcComb" name="optSrc" value="combined" checked>combined
                    </label>
                </div>
                <div class="form-check-inline">
                    <label class="form-check-label" for="srcMC">
                        <input type="radio" class="form-check-input" id="srcMC" name="optSrc" value="base">base
                    </label>
                </div>
                <div class="form-check-inline">
                    <label class="form-check-label" for="srcOL">
                        <input type="radio" class="form-check-input" id="srcOL" name="optSrc" value="openlib">openlib
                    </label>
                </div>
                <div class="form-check-inline">
                    <label class="form-check-label" for="srcAma">
                        <input type="radio" class="form-check-input" id="srcAma" name="optSrc" value="amazon">amazon
                    </label>
                </div>
                <div class="form-inline">
                    <div class="dropdown dropright">
                        <button type="button" class="dropdown-toggle cat-settings-button" data-toggle="dropdown">
                            Add catalogue record
                        </button>
                        <div class="dropdown-menu cat-settings-dropdown">
                            <span class="dropdown-item cat-settings-dropdown-item" id="itmAddCatEnd">At end of catalogue</span>
                            <span class="dropdown-item cat-settings-dropdown-item" id="itmAddCatBeg">At start of catalogue</span>
                            <span class="dropdown-item cat-settings-dropdown-item" id="itmAddAfterSel">After selected record</span>
                            <span class="dropdown-item cat-settings-dropdown-item" id="itmAddBeforeSel">Before selected record</span>
                        </div>
                    </div>
                    <button type="button" id="btnResynch" class="cat-settings-button">
                        (Re)synch with openlib
                    </button>
                    <button type="button" id="btnMinColumns" class="cat-settings-button">
                        Show minimal columns
                    </button>
                </div>
            </div>
        </div>

        <script type="text/javascript" charset="utf-8">
            // ISBN handling
            const REGEX_ISBN13              = new RegExp(/^978[0-9]{9}[0-9X]$/);
            const REGEX_ISBN10              = new RegExp(/^[0-9]{9}[0-9X]$/);
            const ISBN13_PREFIX             = "978";
            const ISBN13_DIGITS             = 13;
            const ISBN13_MOD_FACTOR         = 10;
            const ISBN10_DIGITS             = 10;
            const ISBN10_MAX_DIGIT_WEIGHT   = 10;
            const ISBN10_MOD_FACTOR         = 11;

            // Mapping between currency codes and symbols
            const CURRENCY_SYMBOLS =
            {
                "AUD":  "$",
                "EUR":  "€",
                "GBP":  "£",
                "SGD":  "$SGD",
                "USD":  "$US",
                "VND":  "₫",
                "":     ""
            };

            // Dimension conversions
            const IN_TO_CM  = 2.54
            const LB_TO_OZ  = 16;
            const OZ_TO_KG  = 0.028;
            const LB_TO_KG  = LB_TO_OZ * OZ_TO_KG;
            const G_TO_KG   = 0.001;

            const BCK_FLAG_BIT_OPENLIB_SYNCED   = 0;
            const BCK_FLAG_BIT_IN_OPENLIB       = 1;

            const FLD_ID_MIN                    = 1;

            // Catalogue field keys
            const CAT_FLD_SRC_BASE              = "base";
            const CAT_FLD_SRC_AMAZON            = "amazon";
            const CAT_FLD_SRC_OPENLIB           = "openlib";
            const CAT_FLD_SRC_COMB              = "combined";

            const CAT_FLD_ID                    = "id";
            const CAT_FLD_ISBN13                = "isbn_13";
            const CAT_FLD_ISBN10                = "isbn_10";

            const CAT_FLD_PURCH_DATE            = "purchase_date";
            const CAT_FLD_ARR_DATE              = "arrival_date";

            const CAT_FLD_SELLER                = "seller";
            const CAT_FLD_SELLER_BRANCH         = "seller_branch";
            const CAT_FLD_PURCHASER             = "purchaser";
            const CAT_FLD_PURCH_PRICE           = "purchase_price";
            const CAT_FLD_SHIP_PRICE            = "shipping_price";
            const CAT_FLD_CURRENCY              = "purchase_currency";
            const CAT_FLD_NUM_IN_ORDER          = "number_in_order";
            const CAT_FLD_AUTHORS               = "authors";
            const CAT_FLD_AUTHOR_SURNAME        = "surname";
            const CAT_FLD_AUTHOR_GIVEN_NAMES    = "given_names";
            const CAT_FLD_TITLE                 = "title";
            const CAT_FLD_SUBTITLE              = "subtitle";
            const CAT_FLD_PUBLISHERS            = "publishers";
            const CAT_FLD_PUBLISH_PLACES        = "publish_places";
            const CAT_FLD_FLAGS                 = "flags";
            const CAT_FLD_DIM                   = "dimensions";
            const CAT_FLD_DIM_HEIGHT            = "height";
            const CAT_FLD_DIM_WIDTH             = "width";
            const CAT_FLD_DIM_THICKNESS         = "thickness";
            const CAT_FLD_DIM_LENGTH            = "length";
            const CAT_FLD_DIM_MASS              = "mass";
            const CAT_FLD_DIM_MASS_UNITS        = "mass_units";
            const CAT_FLD_LOCATION              = "location";
            const CAT_FLD_COVER_REQUIRED        = "cover_required";
            const CAT_FLD_NOTES                 = "notes";
            const CAT_FLD_ELEC_FORMAT           = "electronic_format";
            const CAT_FLD_INFO_URL              = "info_url";

            const CAT_FLD_OPENLIB_SYNCH_TIME    = "openlib_synch_time";


            // Open library field keys
            const OLK_DETAILS           = "details";
            const OLK_AUTHORS           = "authors"
            const OLK_AUTHOR_NAME       = "name"
            const OLK_KEY               = "key";
            const OLK_FORMAT            = "physical_format";
            const OLK_DIMENSIONS        = "physical_dimensions";
            const OLK_WEIGHT            = "weight";
            const OLK_PAGES             = "number_of_pages";
            const OLK_PUBLISHERS        = "publishers";
            const OLK_PUBLISH_PLACES    = "publish_places";
            const OLK_PUBLISH_DATE      = "publish_date";
            const OLK_SUBTITLE          = "subtitle";
            const OLK_TITLE             = "title";
            const OLK_URL               = "info_url";

            const NameEnum =
            {
                "NAME_SUR":     0,
                "NAME_GIVEN":   1
            };
            Object.freeze(NameEnum);

            // Delimiters in fields that represent lists
            const LIST_SEP  = ";";
            const AUTH_SEP  = ";";
            const NAME_SEP  = " ";
            const TITLE_SEP = ":";

            const REGEX_EXT         = new RegExp(/[.][^.]*$/);  // File extension regular expression
            const UPDATED_CAT_EXT   = ".updated";

            // Catalogue column definitions listing
            // Each definition comprises an enumerator, column name and
            // (optionally) the path to the column value in a catalogue record,
            // and a flag indicating whether multiple sources apply to the column
            const catColDefList =
            [
                ["COL_ID",              "Cat ID",           [CAT_FLD_ID],                           false],
                ["COL_RESYNCH",         "(Re)synch"                                                      ],
                ["COL_SYNCH_STATUS",    "Synched"                                                        ],
                ["COL_IN_OPENLIB",      "In openlib"                                                     ],
                ["COL_PURCH_DATE",      "Purchase Date",    [CAT_FLD_PURCH_DATE],                   false],
                ["COL_ARR_DATE",        "Arrival Date",     [CAT_FLD_ARR_DATE],                     false],
                ["COL_SELLER",          "Seller",           [CAT_FLD_SELLER],                       false],
                ["COL_SELLER_BRANCH",   "Seller Branch",    [CAT_FLD_SELLER_BRANCH],                false],
                ["COL_PURCHASER",       "Purchaser",        [CAT_FLD_PURCHASER],                    false],
                ["COL_NUM_IN_ORDER",    "#",                [CAT_FLD_NUM_IN_ORDER],                 false],
                ["COL_CURRENCY",        "Currency",         [CAT_FLD_CURRENCY],                     false],
                ["COL_PURCH_PRICE",     "Price",            [CAT_FLD_PURCH_PRICE],                  false],
                ["COL_SHIP_PRICE",      "Shipping",         [CAT_FLD_SHIP_PRICE],                   false],
                ["COL_TOTAL_PRICE",     "Total Price",      null,                                   false],
                ["COL_ISBN_13",         "ISBN 13",          [CAT_FLD_ISBN13],                       false],
                ["COL_ISBN_10",         "ISBN 10",          [CAT_FLD_ISBN10],                       false],
                ["COL_SURNAME",         "Surname"                                                        ],
                ["COL_GIVEN_NAMES",     "Given Name(s)"                                                  ],
                ["COL_TITLE",           "Title"                                                          ],
                ["COL_PUB_NAME",        "Name(s)",          [CAT_FLD_PUBLISHERS]                         ],
                ["COL_PUB_PLACE",       "Place(s)",         [CAT_FLD_PUBLISH_PLACES]                     ],
                ["COL_PUB_DATE",        "Date"                                                           ],
                ["COL_DIM_HEIGHT",      "H (cm)",           [CAT_FLD_DIM, CAT_FLD_DIM_HEIGHT]            ],
                ["COL_DIM_WIDTH",       "W (cm)",           [CAT_FLD_DIM, CAT_FLD_DIM_WIDTH]             ],
                ["COL_DIM_THICKNESS",   "T (cm)",           [CAT_FLD_DIM, CAT_FLD_DIM_THICKNESS]         ],
                ["COL_DIM_LENGTH",      "Length (pp)",      [CAT_FLD_DIM, CAT_FLD_DIM_LENGTH]            ],
                ["COL_DIM_MASS",        "Mass (kg)",        [CAT_FLD_DIM, CAT_FLD_DIM_MASS]              ],
                ["COL_LOCATION",        "Location",         [CAT_FLD_LOCATION],                     false],
                ["COL_COVER_REQUIRED",  "Cover Required?",  [CAT_FLD_COVER_REQUIRED],               false],
                ["COL_NOTES",           "Notes",            [CAT_FLD_NOTES],                        false],
                ["COL_ELEC_FORMAT",     "Electronic Copy",  [CAT_FLD_ELEC_FORMAT],                  false]
            ];

            // Convert column listings into an enum and an enum val => details mapping
            let CatColEnum  = {};
            let catColDefs   = {};

            let indexedList = catColDefList.entries();
            for (indexedPair of indexedList)
            {
                let colEnumVal = indexedPair[0];

                let colDetails      = indexedPair[1];
                let colEnumerator   = colDetails.shift();
                let colName         = colDetails.shift();
                let colCatRecPath   = colDetails.length > 0 ? colDetails.shift() : null;
                let colAllSrcs      = colDetails.length > 0 ? colDetails.shift() : true;

                CatColEnum[colEnumerator] = colEnumVal;
                catColDefs[colEnumVal] = {
                                            name:       colName,
                                            catRecPath: colCatRecPath,
                                            allSrcs:    colAllSrcs
                                          };
            }

            // Lock down the column identifier objects
            Object.freeze(catColDefList);
            Object.freeze(CatColEnum);
            Object.freeze(catColDefs);

            // Default column options
            const defaultCatCol =
            {
                sortable:       true,
                filter:         true,
                floatingFilter: true,
                filterParams:
                {
                    buttons:                ["clear", "reset"],
                    suppressAndOrCondition: true
                },
                resizable:          true,
                editable:           true,
                menuTabs:           ["columnsMenuTab"],

                headerValueGetter:  'catColDefs[parseInt(colDef.colId)].name',   // Retrieve header name via colId
                valueGetter:        'getFldValByColId(data, parseInt(colDef.colId))',
                valueSetter:        'setFldValByColId(data, colDef.colId, newValue)',
                tooltipValueGetter: getColTooltip
            };

            // Group header names
            const COL_GRP_HDR_SYNCH         = "Openlib synch status";
            const COL_GRP_HDR_PURCHASE      = "Purchase Details";
            const COL_GRP_HDR_AUTHOR        = "Author/Editor";
            const COL_GRP_HDR_IDENTIFIERS   = "Identifiers";
            const COL_GRP_HDR_PUB           = "Publisher Details";
            const COL_GRP_HDR_PHYS          = "Physical Details";

            // Properties of a single catalogue field
            const FLD_SRC   = "source";
            const FLD_VAL   = "value";

            const minCols = [  CatColEnum.COL_ID,
                               CatColEnum.COL_SURNAME, CatColEnum.COL_GIVEN_NAMES,
                               CatColEnum.COL_PURCH_DATE,
                               CatColEnum.COL_ISBN_13, CatColEnum.COL_TITLE,
                               CatColEnum.COL_PUB_NAME,
                               CatColEnum.COL_DIM_HEIGHT, CatColEnum.COL_DIM_WIDTH, CatColEnum.COL_DIM_THICKNESS,
                               CatColEnum.COL_DIM_LENGTH];

            // Column definitions
            let bookColumns =
            [
                {
                    colId:          CatColEnum.COL_ID,
                    headerTooltip:  "Master identifier for the catalogue record (automatically generated)",
                    editable:       false,
                    filter:         "agNumberColumnFilter"
                },
                {
                    headerName: COL_GRP_HDR_SYNCH,
                    children:
                    [
                        {
                            colId:                                  CatColEnum.COL_RESYNCH,
                            headerTooltip:                          "Check for updated openlib details",
                            headerCheckboxSelection:                true,   // Allow selection of all rows
                            headerCheckboxSelectionFilteredOnly:    true,   // included by filtering
                            checkboxSelection:                      true,
                            filter:                                 false
                        },
                        {
                            colId:          CatColEnum.COL_SYNCH_STATUS,
                            headerTooltip:  "Is the record synched with openlib?",
                            editable:       false,
                            valueGetter:    'isFlagSet(data, BCK_FLAG_BIT_OPENLIB_SYNCED) ? "✓" : ""'
                        },
                        {
                            colId:          CatColEnum.COL_IN_OPENLIB,
                            headerTooltip:  "Book exists in openlib",
                            editable:       false,
                            valueGetter:    'isFlagSet(data, BCK_FLAG_BIT_IN_OPENLIB) ? "✓" : ""'
                        }
                    ]
                },
                {
                    headerName: COL_GRP_HDR_PURCHASE,
                    children:
                    [
                        {
                            colId:      CatColEnum.COL_PURCH_DATE,
                            editable:   true,
                            cellEditor: "datePicker",
                            valueFormatter: function(params)
                            {
                                return getDateString(params.value);
                            },
                            cellRenderer: function(params)
                            {
                                return markFldValidity(params, params.valueFormatted);
                            },
                            filter:                     "dateFilterComponent",
                            floatingFilterComponent:    "dateFloatingFilterComponent",
                            comparator: compareDates
                        },
                        {
                            colId:      CatColEnum.COL_ARR_DATE,
                            editable:   true,
                            cellEditor: "datePicker",
                            valueFormatter: function(params)
                            {
                                return getDateString(params.value);
                            },
                            cellRenderer: function(params)
                            {
                                return markFldValidity(params, params.valueFormatted);
                            },
                            filter:                     "dateFilterComponent",
                            floatingFilterComponent:    "dateFloatingFilterComponent",
                            comparator:                 compareDates,
                            hide:                       true
                        },
                        {colId: CatColEnum.COL_SELLER},
                        {colId: CatColEnum.COL_SELLER_BRANCH, hide: true},
                        {colId: CatColEnum.COL_PURCHASER, hide: true},
                        {colId: CatColEnum.COL_NUM_IN_ORDER, hide: true},
                        {
                            colId:      CatColEnum.COL_CURRENCY,
                            cellEditor: "agRichSelectCellEditor",
                            cellEditorParams:
                            {
                                values: Object.keys(CURRENCY_SYMBOLS)
                            },
                            onCellValueChanged: function(params)
                            {
                                gridOptions.api.redrawRows();
                            },
                            hide: true
                        },
                        {
                            colId:  CatColEnum.COL_PURCH_PRICE,
                            cellRenderer: function(params)
                            {
                                cellString = isFldValid(params) ? formatAsCurrency(params) : params.value;
                                return markFldValidity(params, cellString);
                            },
                            filter: "agNumberColumnFilter"
                        },
                        {
                            colId:  CatColEnum.COL_SHIP_PRICE,
                            cellRenderer: function(params)
                            {
                                cellString = isFldValid(params) ? formatAsCurrency(params) : params.value;
                                return markFldValidity(params, cellString);
                            },
                            filter: "agNumberColumnFilter",
                            hide:   true
                        },
                        {
                            colId:      CatColEnum.COL_TOTAL_PRICE,
                            editable:   false,
                            cellRenderer: function(params)
                            {
                                return (formatAsCurrency(params));
                            },
                            filter:   "agNumberColumnFilter"
                        },
                    ]
                },
                {
                    headerName: COL_GRP_HDR_AUTHOR,
                    suppressMenu: false,
                    children:
                    [
                        {colId: CatColEnum.COL_SURNAME},
                        {colId:  CatColEnum.COL_GIVEN_NAMES}
                    ]
                },
                {
                    headerName: COL_GRP_HDR_IDENTIFIERS,
                    children:
                    [

                        {
                            colId:  CatColEnum.COL_ISBN_13,
                            headerToolTip:  "13 digit international standard book number",
                            cellRenderer: function(params)
                            {
                                let cellString = params.value;
                                return markFldValidity(params, cellString);
                            }
                        },
                        {
                            colId:  CatColEnum.COL_ISBN_10,
                            headerToolTip:  "10 digit international standard book number",
                            cellRenderer: function(params)
                            {
                                let cellString = params.value;
                                return markFldValidity(params, cellString);
                            }
                        },
                        {
                            colId:  CatColEnum.COL_TITLE,
                            cellRenderer: function(params)
                            {
                                let cellString = params.value;
                                let infoUrl = getFldVal(params.data, [CAT_FLD_INFO_URL], CAT_FLD_SRC_OPENLIB);
                                if (infoUrl)
                                {
                                    cellString = "<a href='" + infoUrl + "' target='_blank'>" + cellString + "</a>";
                                }
                                return cellString;
                            }
                        },
                    ]
                },
                {
                    headerName: COL_GRP_HDR_PUB,
                    children:
                    [
                        {colId: CatColEnum.COL_PUB_NAME},
                        {colId: CatColEnum.COL_PUB_PLACE, hide: true}
                    ]
                },
                {
                    headerName: COL_GRP_HDR_PHYS,
                    children:
                    [
                        {
                            colId:  CatColEnum.COL_DIM_HEIGHT,
                            filter: "agNumberColumnFilter",
                            hide:   true
                        },
                        {
                            colId:  CatColEnum.COL_DIM_WIDTH,
                            filter: "agNumberColumnFilter",
                            hide:   true
                        },
                        {
                            colId:  CatColEnum.COL_DIM_THICKNESS,
                            filter: "agNumberColumnFilter",
                            hide:   true
                        },
                        {
                            colId:  CatColEnum.COL_DIM_LENGTH,
                            filter: "agNumberColumnFilter",
                            hide:   true
                        },
                        {
                            colId:  CatColEnum.COL_DIM_MASS,
                            cellRenderer: function(params)
                            {
                                if (params.value)
                                {
                                    cellString = formatAsMass(params.value);
                                    if (!isFldValid(params))
                                    {
                                    }
                                    return (formatAsMass(params.value));
                                }
                            },
                            filter: "agNumberColumnFilter",
                            hide:   true
                        },
                        {colId: CatColEnum.COL_LOCATION},
                        {colId: CatColEnum.COL_COVER_REQUIRED, hide: true},
                    ]
                },
                {colId: CatColEnum.COL_NOTES},
                {colId: CatColEnum.COL_ELEC_FORMAT}
            ];

            // Default grid configuration (empty data)
            let gridOptions =
            {
                defaultColDef:          defaultCatCol,
                columnDefs:             bookColumns,
                tooltipShowDelay:       0,

                // Unique identifier for each row
                getRowNodeId: function(data)
                {
                    return data[CAT_FLD_ID];
                },

                rowSelection:           "multiple",
                rowDeselection:         true,           // Allow deselecting rows with Ctrl-click
                enableRangeSelection:   true,           // Allow multiple values in the same column to be selected/copied
                suppressRowTransform:   true,           // Allow row spanning
                onRowSelected: function(params)
                {
                    if (getFldVal(params.data, [CAT_FLD_FLAGS], CAT_FLD_SRC_BASE))
                    {
                        // Toggle selected item's openlib (re)synch flag
                        params.data.flags ^= (1 << BCK_FLAG_BIT_OPENLIB_SYNCED);
                    }
                },

                undoRedoCellEditing:    true,

                statusBar:
                {
                    statusPanels:
                    [
                        {
                            statusPanel:    "agTotalAndFilteredRowCountComponent",
                            align:          "left"
                        }
                    ]
                },

                getContextMenuItems:    getCatContextMenu,

                components:
                {
                    dateFilterComponent: getDateFilterComponent(),
                    dateFloatingFilterComponent: getDateFloatingFilterComponent(),
                    datePicker: getDateComponent()
                },
                rowData:                []
            };

            let catFilename = "";   // Catalogue file name
            let catData     = [];   // Catalogue data array

            let catFilters = null;  // Saved catalogue filters


            $(document).ready(function()
            {
                // Initialise the catalogue grid
                let gridDiv = document.querySelector("#catGrid");
                new agGrid.Grid(gridDiv, gridOptions);
                loadDefaultCat();
                showMinimalColumns();

                // Load/display selected catalogue data
                $("#btnLoad").click(function()
                {
                    loadSelectedCat();
                });

                $("#fileinputCat").change(function()
                {
                    // Load catalogue data in response to file selection
                    loadSelectedCat();
                });

                $("#btnNew").click(function()
                {
                    // Clear existing data and repopulate the grid
                    catData.length = 0;
                    populateGrid(catData);
                });

                $("#btnLoadDefault").click(function()
                {
                    // Load catalogue data in response to button click
                    loadDefaultCat();
                });

                // Save a version of the catalogue file with selected items flagged
                // for resynch with openlib
                $("#btnProcessUpdates").click(function()
                {
                    let catDataString = JSON.stringify(catData, null, 4);
                    let updatedCatFile = new Blob([catDataString], {type: "text/plain;charset=UTF-8"});
                    let updatedCatFileElem = document.createElement("a");
                    updatedCatFileElem.href = URL.createObjectURL(updatedCatFile);

                    // Generate updated catalogue filename
                    let catFilenameExt  = REGEX_EXT.exec(catFilename);
                    let updatedCatFilename = catFilename.replace(catFilenameExt, UPDATED_CAT_EXT + catFilenameExt);
                    updatedCatFileElem.download = updatedCatFilename;

                    updatedCatFileElem.click();
                });

                // Toggle the catalogue data source
                $("[name='optSrc']").click(function()
                {
                    gridOptions.api.redrawRows();
                });

                // Add record at end of catalogue
                $("#itmAddCatEnd").click(function()
                {
                    addCatRec(getMaxGridIdx(), getMaxDataIdx(), getMaxRecId() + 1, true);
                });

                // Add record at beginning of catalogue
                $("#itmAddCatBeg").click(function()
                {
                    addCatRec(0, 0, getMinRecId(), false);
                });

                // Add record after first selected grid row
                $("#itmAddAfterSel").click(function()
                {
                    // Defaults if nothing is selected (add record at end)
                    let gridRefIdx  = getMaxGridIdx();
                    let dataRefIdx  = getMaxDataIdx();
                    let newId       = getMaxRecId() + 1;

                    let gridSelections = gridOptions.api.getSelectedNodes();
                    let firstGridSelection = gridSelections.length > 0 ? gridSelections[0] : null;
                    if (firstGridSelection)
                    {
                        gridRefIdx = firstGridSelection.rowIndex;
                        dataRefIdx = catData.indexOf(firstGridSelection.data);
                        newId = firstGridSelection.data[CAT_FLD_ID] + 1;
                    }

                    addCatRec(gridRefIdx, dataRefIdx, newId, true);
                });

                // Add record before first selected grid row
                $("#itmAddBeforeSel").click(function()
                {
                    // Defaults if nothing is selected (add record at beginning)
                    let gridRefIdx  = 0;
                    let dataRefIdx  = 0;
                    let newId       = getMinRecId();

                    let gridSelections = gridOptions.api.getSelectedNodes();
                    let firstGridSelection = gridSelections.length > 0 ? gridSelections[0] : null;
                    if (firstGridSelection)
                    {
                        gridRefIdx = firstGridSelection.rowIndex;
                        dataRefIdx = catData.indexOf(firstGridSelection.data);
                        newId = firstGridSelection.data[CAT_FLD_ID];
                    }

                    addCatRec(gridRefIdx, dataRefIdx, newId, false);
                });

                $("#btnResynch").click(function()
                {
                    synchSelectedRecs();
                });

                $("#btnMinColumns").click(function()
                {
                    showMinimalColumns();
                });
            });


            // Loads the default catalogue
            function loadDefaultCat()
            {
                catFilename = "Books.cat";

                let xmlhttp = new XMLHttpRequest();
                xmlhttp.onreadystatechange = function()
                {
                    if (this.readyState == 4 && this.status == 200)
                    {
                        catData = JSON.parse(this.responseText);
                        populateGrid(catData);
                    }
                };
                xmlhttp.open("GET", catFilename, true);
                xmlhttp.send();
            }

            // Loads a selected catalogue
            function loadSelectedCat()
            {
                let fileinput, fileReader;

                // Parse file input element
                fileinput = document.getElementById("fileinputCat");
                if (!fileinput)
                {
                    alert("Couldn't find the catalogue file HTML element.");
                }
                else if (!fileinput.files)
                {
                    alert("This browser doesn't seem to support the `files` property of file inputs.");
                }
                else if (!fileinput.files[0])
                {
                    alert("Please select a catalogue file before clicking 'Load'");
                }
                else
                {
                    catFilename = fileinput.files[0].name;
                    catFile = fileinput.files[0];
                    fileReader = new FileReader();
                    fileReader.onload = receivedText;
                    fileReader.readAsText(catFile);
                }

                // Proceess catalogue file contents
                function receivedText(e)
                {
                    catData = JSON.parse(e.target.result);
                    populateGrid(catData);
                }
            }

            // Populate the catalogue grid
            function populateGrid(catData)
            {
                catData.sort(compareRecs);
                gridOptions.api.setRowData(catData);
                gridOptions.columnApi.autoSizeColumns();
                gridOptions.api.sizeColumnsToFit();

                document.getElementById("divCatInfo").innerHTML = "Displaying catalogue: '" + catFilename + "'";
            }

            // Show a minimal number of columns (useful for debugging)
            function debugCols()
            {
                console.log("debugCols()");
                let allColumns = gridOptions.columnApi.getAllColumns();
                for (let idx = 0; idx < allColumns.length; idx++)
                {
                    let colId = allColumns[idx].colDef.colId;
                    console.log(allColumns[idx].colId + "\tvs.\t" + colId);
                }
            }

            // Show a minimal number of columns (useful for debugging)
            function showMinimalColumns()
            {
                let allColumns = gridOptions.columnApi.getAllColumns();
                for (let idx = 0; idx < allColumns.length; idx++)
                {
                    let colId   = allColumns[idx].colDef.colId;
                    let visible = (minCols.indexOf(colId) != -1);
                    gridOptions.columnApi.setColumnVisible(allColumns[idx], visible);
                }
                gridOptions.api.sizeColumnsToFit();
            }

            function getCol(colId)
            {
                let allColumns = gridOptions.columnApi.getAllColumns();
                for (let idx = 0; idx < allColumns.length; idx++)
                {
                    let col = allColumns[idx];
                    if (col.colDef.colId == colId)
                    {
                        return col;
                    }
                }
                return null;
            }

            // Defines the menu that appears when a cell is right-clicked
            function getCatContextMenu(params)
            {
                // Default items
                let menuItems =
                [
                    "copy",
                    "export",
                    {
                        name:   "Synch With Openlib",
                        action: function()
                        {
                            // Save grid selection(s)
                            let currSelectedNodes = gridOptions.api.getSelectedNodes();

                            // Set the clicked node as the sole selection
                            params.node.setSelected(true, true);

                            // Synch!
                            synchSelectedRecs();

                            // Restore grid selection(s)
                            currSelectedNodes.forEach(function(node)
                                {
                                    node.setSelected(true);
                                }
                            );
                        }
                    },
                    {
                        name:   "Delete",
                        action: function()
                        {
                            // Save grid selection(s)
                            let currSelectedNodes = gridOptions.api.getSelectedNodes();

                            // Set the clicked node as the sole selection
                            params.node.setSelected(true, true);

                            // Delete!
                            delSelectedRecs();

                            // Restore grid selection(s)
                            currSelectedNodes.forEach(function(node)
                                                     {
                                                         node.setSelected(true);
                                                     }
                                               );
                        }
                    },
                    "separator",
                    {
                        name:   "Synch Selected With Openlib",
                        action: function()
                        {
                            synchSelectedRecs();
                        }
                    },
                    {
                        name:   "Delete Selected",
                        action: function()
                        {
                            delSelectedRecs();
                        }
                    },
                    "separator",
                    "autoSizeAll",
                    "resetColumns",
                    {
                        name:   "Reset filters",
                        action: function()
                        {
                            gridOptions.api.setFilterModel(null);
                            gridOptions.api.onFilterChanged();
                        }
                    }
                ];

                let colId = params.column ? params.column.colDef.colId : null;
                switch (colId)
                {
                    case null:
                    {
                        break;
                    }

                    // For the ISBN13/10 columns, add an item for filling in
                    // the value by converting the counterpart ("source") ISBN
                    case CatColEnum.COL_ISBN_10:
                    case CatColEnum.COL_ISBN_13:
                    {
                        let srcISBNCol      = colId == CatColEnum.COL_ISBN_13 ? getCol(CatColEnum.COL_ISBN_10) : getCol(CatColEnum.COL_ISBN_13);
                        let srcISBNName     = srcISBNCol ? gridOptions.columnApi.getDisplayNameForColumn(srcISBNCol) : null;
                        let srcISBNDigits   = colId == CatColEnum.COL_ISBN_13 ? ISBN10_DIGITS : ISBN13_DIGITS;
                        let srcISBN         = srcISBNCol ? getFldValByColId(params.node.data, srcISBNCol.colDef.colId) : null;

                        let menuItemAutofillISBN =
                        {
                            name: "Fill in based on " + srcISBNName,

                            // Disable fill-in if the source ISBN is invalid
                            disabled: !isISBNValid(srcISBN, srcISBNDigits),

                            action: function()
                            {
                                let newISBN = convISBN(srcISBN);
                                if (newISBN)
                                {
                                    setFldValByColId(params.node.data, colId, newISBN);
                                    gridOptions.api.refreshCells(params.node);
                                }
                            }
                        };
                        menuItems.push("separator");
                        menuItems.push(menuItemAutofillISBN);
                    }

                    default:
                    {
                        if (catColDefs[colId].allSrcs)
                        {
                            // If the column supports multiple data sources,
                            // add a menu item for copying from each data
                            // source that has a non-null value for the column
                            let dataSrcs    = [CAT_FLD_SRC_BASE, CAT_FLD_SRC_OPENLIB, CAT_FLD_SRC_AMAZON];
                            let currDataSrc = getDataSrc();

                            if (currDataSrc == CAT_FLD_SRC_BASE || currDataSrc == CAT_FLD_SRC_OPENLIB)
                            {
                                menuItems.push("separator");

                                let candidateSrcs = dataSrcs.filter(function(dataSrc) { return dataSrc != currDataSrc; });
                                candidateSrcs.forEach
                                (
                                    function(dataSrc)
                                    {
                                        let menuItemCopyFromSrc =
                                        {
                                            name: "Copy from " + dataSrc  + " data",

                                            disabled: !getFldValByColId(params.node.data, colId, dataSrc),

                                            action: function()
                                            {
                                                let srcVal = getFldValByColId(params.node.data, colId, dataSrc);
                                                setFldValByColId(params.node.data, colId, srcVal, currDataSrc);
                                                gridOptions.api.refreshCells(params.node);
                                            }
                                        };
                                        menuItems.push(menuItemCopyFromSrc);

                                    }
                                );
                            }
                        }

                        if (params.column.colDef.editable)
                        {
                            let menuItemEdit =
                            {
                                name: "Edit",
                                action: function()
                                {
                                    let cellDetails =
                                    {
                                        rowIndex:   gridOptions.api.rowModel.rowsToDisplay.indexOf(params.node),
                                        colKey:     colId
                                    };
                                    gridOptions.api.startEditingCell(cellDetails);
                                }
                            }
                            menuItems.splice(0, 0, menuItemEdit);
                        }
                        break;
                    }
                }

                return menuItems;
            }

            // Synch the selected records
            function synchSelectedRecs()
            {
                gridOptions.api.getSelectedNodes().forEach(synchWithOpenlib);
            }

            // Synch the record associated with a grid node with openlib
            function synchWithOpenlib(gridNode)
            {
                let isbn = gridNode.data[CAT_FLD_ISBN13];
                if (isbn)
                {
                    $.ajax(
                    {
                        url: "https://openlibrary.org/api/books?bibkeys=" + isbn + "&jscmd=details&format=json",
                        dataType: "json",
                        success: function(queryRes)
                        {
                            let catRec = gridNode.data;

                            // Clear any existing openlib data for the record
                            setFldVal(catRec, [CAT_FLD_SRC_OPENLIB], {}, CAT_FLD_SRC_BASE);

                            let olRec = queryRes[isbn];
                            if (olRec && olRec[OLK_DETAILS])
                            {
                                // Process author data
                                let auths = [];
                                let olRecAuths = olRec[OLK_DETAILS][CAT_FLD_AUTHORS];
                                if (olRecAuths)
                                {
                                    for (let idx = 0; idx < olRecAuths.length; idx++)
                                    {
                                        let authNames = olRecAuths[idx][OLK_AUTHOR_NAME].split(" ");
                                        let openlibAuth = {};
                                        openlibAuth[CAT_FLD_AUTHOR_SURNAME] = authNames.length > 0 ? authNames.pop() : null;
                                        openlibAuth[CAT_FLD_AUTHOR_GIVEN_NAMES] = authNames;
                                        auths.push(openlibAuth);
                                    }
                                    setFldVal(catRec, [CAT_FLD_AUTHORS], auths, CAT_FLD_SRC_OPENLIB);
                                }

                                // Process dimensions, length and mass
                                let olDimStr = olRec[OLK_DETAILS][OLK_DIMENSIONS];
                                if (olDimStr)
                                {
                                    // Assume OL dimensions are in inches
                                    let dimComponents = olDimStr.split(new RegExp(/\s+x\s+|\s+/));
                                    let olHeight = parseFloat(dimComponents.shift()) * IN_TO_CM;
                                    let olWidth = parseFloat(dimComponents.shift()) * IN_TO_CM;
                                    let olThickness = parseFloat(dimComponents.shift()) * IN_TO_CM;
                                    setFldVal(catRec, [CAT_FLD_DIM, CAT_FLD_DIM_HEIGHT], olHeight, CAT_FLD_SRC_OPENLIB);
                                    setFldVal(catRec, [CAT_FLD_DIM, CAT_FLD_DIM_WIDTH], olWidth, CAT_FLD_SRC_OPENLIB);
                                    setFldVal(catRec, [CAT_FLD_DIM, CAT_FLD_DIM_THICKNESS], olThickness, CAT_FLD_SRC_OPENLIB);
                                }

                                setFldVal(catRec, [CAT_FLD_DIM, CAT_FLD_DIM_LENGTH], olRec[OLK_DETAILS][OLK_PAGES], CAT_FLD_SRC_OPENLIB);

                                let olMassStr = olRec[OLK_DETAILS][OLK_WEIGHT];
                                if (olMassStr)
                                {
                                    let olMassComponents = olMassStr.trim().split(new RegExp(/\s+/));
                                    let olMass = olMassComponents.shift();
                                    let olMassUnits = olMassComponents.length > 0 ? olMassComponents.shift() : null;
                                    if (!isNaN(olMass))
                                    {
                                        setFldVal(catRec, [CAT_FLD_DIM, CAT_FLD_DIM_MASS], parseFloat(olMass), CAT_FLD_SRC_OPENLIB);
                                    }
                                    setFldVal(catRec, [CAT_FLD_DIM, CAT_FLD_DIM_MASS_UNITS], olMassUnits, CAT_FLD_SRC_OPENLIB);
                                }

                                // Process miscellaneous details
                                let olSubkeys = [OLK_FORMAT, OLK_KEY, OLK_PUBLISHERS, OLK_PUBLISH_PLACES, OLK_PUBLISH_DATE, OLK_SUBTITLE, OLK_TITLE];
                                for (let idx = 0; idx < olSubkeys.length; idx++)
                                {
                                    subkey = olSubkeys[idx];
                                    setFldVal(catRec, [subkey], olRec[OLK_DETAILS][subkey], CAT_FLD_SRC_OPENLIB);
                                }

                                setFldVal(catRec, [OLK_URL], olRec[OLK_URL], CAT_FLD_SRC_OPENLIB);

                                // Mark the record as having an openlib equivalent
                                setFlag(catRec, BCK_FLAG_BIT_IN_OPENLIB);
                            }
                            else
                            {
                                clearFlag(catRec, BCK_FLAG_BIT_IN_OPENLIB);
                            }

                            // Mark the record as in synch
                            setFlag(catRec, BCK_FLAG_BIT_OPENLIB_SYNCED);

                            // Set the synch time
                            let synchTime = new Date();
                            let synchTimeString = formatAsDate(synchTime.getFullYear(),
                                                               synchTime.getMonth() + 1,
                                                               synchTime.getDate()) + " " +
                                                  synchTime.toTimeString();
                            setFldVal(catRec, [CAT_FLD_OPENLIB_SYNCH_TIME], synchTimeString, CAT_FLD_SRC_BASE);

                            gridOptions.api.refreshCells(gridNode);
                        }
                    });
                }
            }

            // Returns the minimum catalogue record ID
            function getMinRecId()
            {
                let minId = catData.length > 0 ? catData[0][CAT_FLD_ID] : 0;
                for (let idx = 0; idx < catData.length; idx++)
                {
                    minId = Math.min(minId, catData[idx][CAT_FLD_ID]);
                }
                return (minId);
            }

            // Returns the maximum grid index
            function getMaxGridIdx()
            {
                let gridRows = gridOptions.api.rowModel.rowsToDisplay;
                return gridRows.length > 0 ? gridRows.length - 1 : -1;
            }

            // Returns the maximum data array index
            function getMaxDataIdx()
            {
                return catData.length > 0 ? catData.length - 1 : -1;
            }

            // Returns the maximum catalogue record ID
            function getMaxRecId()
            {
                let maxId = 0;
                for (let idx = 0; idx < catData.length; idx++)
                {
                    maxId = Math.max(maxId, catData[idx][CAT_FLD_ID]);
                }
                return (maxId);
            }

            // Adds a catalogue record relative to the positions given in the
            // grid (i.e. the catalogue as displayed) and the underlying data.
            // Note that the grid insertion does not work as desired if sorting
            // on a field other than the ID has been applied.
            function addCatRec(gridRefIdx, dataRefIdx, recId, addAfterRefIdx = true)
            {
                // The grid/data positions where the new rcord will be added
                let gridAddIdx = addAfterRefIdx ? gridRefIdx + 1 : gridRefIdx;
                let dataAddIdx = addAfterRefIdx ? dataRefIdx + 1 : dataRefIdx;

                // Create new record with required ID
                let catRec = {};
                catRec[CAT_FLD_ID] = recId;

                // Add the new record to a copy of the catalogue data array,
                // update IDs of the records that followi it, then reassign the
                // catalogue data array to point to the new data.
                let updatedCatData = catData.slice();
                updatedCatData.splice(dataAddIdx, 0, catRec);
                for (let idx = dataAddIdx + 1; idx < updatedCatData.length; idx++)
                {
                    updatedCatData[idx][CAT_FLD_ID]++;
                }
                catData = updatedCatData;

                // Update the grid's row data
                gridOptions.api.setRowData(catData);

                // Scroll to the added record
                gridOptions.api.ensureIndexVisible(gridAddIdx);
            }

            // Deletes the selected records
            function delSelectedRecs()
            {
                let delRows = gridOptions.api.getSelectedRows();
                if (delRows.length > 0)
                {
                    // Copy the data array for updating
                    let updatedCatData = catData.slice();

                    // Identify the catalogue records to be deleted
                    let delIds = delRows.map(function(row) { return gridOptions.getRowNodeId(row); }).sort(function(a, b) { return a - b; });
                    let minDelIdx = updatedCatData.findIndex(function(catRec) { return gridOptions.getRowNodeId(catRec) == delIds[0]; });

                    // Update the data array by filtering out the deleted IDs
                    updatedCatData = updatedCatData.filter(function(catRec) { return delIds.indexOf(gridOptions.getRowNodeId(catRec)) < 0; });

                    // Ensure remaining IDs are contiguous.

                    // Special handling of deletion of first record.
                    if (minDelIdx == 0 && updatedCatData.length > 0)
                    {
                        updatedCatData[0][CAT_FLD_ID]--;
                    }

                    // Compress IDs of records following the first one deleted
                    for (let idx = Math.max(minDelIdx, 1); idx < updatedCatData.length; idx++)
                    {
                        updatedCatData[idx][CAT_FLD_ID] = updatedCatData[idx-1][CAT_FLD_ID] + 1;
                    }

                    // Synch changes with the grid's row data
                    catData = updatedCatData;

                    // Update the grid's row data
                    gridOptions.api.setRowData(catData);
                }
            }

            // Function for comparing two catalogue records
            function compareRecs(catRec1, catRec2)
            {
                return (catRec1[CAT_FLD_ID] - catRec2[CAT_FLD_ID]);
            }

            // Identifies the catalogue data source
            function getDataSrc()
            {
                return ($("[name='optSrc']:checked").val());
            }

            // Fetches a field from a catalogue record, via a path consisting
            // of a sequence of keys and assuming the data source specified
            // by the dataSrc parameter.
            // Returns the source and value of any field actually retrieved,
            // with recourse to a default value if required.
            //
            // If the "combined" data source is selected, the function
            // checks each of the three data sources in turn for a non-null
            // field.
            function getFld(catRec, path, dataSrc = getDataSrc(), defVal = null)
            {
                let fldFound = false;   // Flag set when a non-null field is found
                let fldSrc   = null;    // Data source of any field found
                let fldVal   = null;    // Value of any field found

                // Search until the target field is found, or the list of field
                // sources has been exhausted
                let dataSrcList = dataSrc == CAT_FLD_SRC_COMB ? [CAT_FLD_SRC_BASE, CAT_FLD_SRC_OPENLIB, CAT_FLD_SRC_AMAZON] : [dataSrc];
                while(dataSrcList.length > 0 && !fldFound)
                {
                    fldSrc = dataSrcList.shift();
                    let fldKeyPrefix = (fldSrc == CAT_FLD_SRC_BASE) ? [] : [fldSrc];
                    let fldPath = fldKeyPrefix.concat(path);

                    // Recursive fetching of object properties...
                    let obj = catRec;
                    while (fldPath.length > 0 && fldPath[0] in obj)
                    {
                        obj = obj[fldPath.shift()];
                    }
                    fldFound = (fldPath.length == 0);
                    fldVal = fldFound ? obj : null;
                }

                let fld = {};
                if (fldFound)
                {
                    fld[FLD_SRC] = fldSrc;
                    fld[FLD_VAL] = fldVal;
                }
                else
                {
                    fld[FLD_SRC] = null;
                    fld[FLD_VAL] = defVal;
                }

                return fld;
            }

            // Fetches a field from a catalogue record, compressing the value
            // (a list) into a single string
            function getListFld(catRec, path, dataSrc)
            {
                let fld         = getFld(catRec, path, dataSrc);
                let fldVal      = fld[FLD_VAL];
                fld[FLD_VAL]    = fldVal ? fldVal.join(LIST_SEP + " ") : null;

                return fld;
            }

            // Fetches a field value from a catalogue record, via a path
            // consisting of a sequence of keys and assuming the data source
            // specified by the dataSrc parameter.
            // Returns a default value if the field doesn't exist.
            function getFldVal(catRec, path, dataSrc = getDataSrc(), defVal = null)
            {
                let fld = getFld(catRec, path, dataSrc, defVal);
                return fld[FLD_VAL];
            }

            // Helper function that checks if a field has a non-null value
            function fldHasValue(fld)
            {
                return (fld[FLD_VAL] != null);
            }

            // Fetches a field from a catalogue record, via its column id
            // and assuming the data source specified by the dataSrc parameter.
            // Some columns require special handling.
            // Otherwise the field is fetched using the catalogue record path
            // specified in catColDefs.
            function getFldByColId(catRec, colId, dataSrc = getDataSrc())
            {
                let fld = {};
                switch (colId)
                {
                    case CatColEnum.COL_ARR_DATE:
                        fld = getFld(catRec, catColDefs[colId].catRecPath, CAT_FLD_SRC_BASE);
                        if (!fldHasValue(fld))
                        {
                            fld = getFld(catRec, catColDefs[CatColEnum.COL_PURCH_DATE].catRecPath, CAT_FLD_SRC_BASE);
                        }
                        break;

                    case CatColEnum.COL_TOTAL_PRICE:
                        fld = getTotalPriceFld(catRec)
                        break;

                    case CatColEnum.COL_SURNAME:
                        fld = getAuthorNamesFld(catRec, NameEnum.NAME_SUR, dataSrc);
                        break;

                    case CatColEnum.COL_GIVEN_NAMES:
                        fld = getAuthorNamesFld(catRec, NameEnum.NAME_GIVEN, dataSrc);
                        break;

                    case CatColEnum.COL_TITLE:
                        fld = getTitleFld(catRec, dataSrc);
                        break;

                    case CatColEnum.COL_PUB_NAME:
                    case CatColEnum.COL_PUB_PLACE:
                        fld = getListFld(catRec, catColDefs[colId].catRecPath, dataSrc);
                        break;

                    case CatColEnum.COL_DIM_MASS:
                        fld = getMassFld(catRec, dataSrc);
                        break;

                    default:
                        if (catColDefs[colId].catRecPath)
                        {
                            let catRecDataSrc = catColDefs[colId].allSrcs ? dataSrc : CAT_FLD_SRC_BASE;
                            fld = getFld(catRec, catColDefs[colId].catRecPath, catRecDataSrc);
                        }
                        break;
                }
                return fld;
            }

            // Fetches a field value from a catalogue record, via its column id
            // and assuming the data source specified by the dataSrc parameter.
            function getFldValByColId(catRec, colId, dataSrc = getDataSrc())
            {
                let fld = getFldByColId(catRec, colId, dataSrc);
                return fld[FLD_VAL];
            }

            // Sets the value of the field located at the specified path.
            // If the catalogue is currently viewed with combined data sources,
            // edits are directed to the base source.
            function setFldVal(catRec, path, value, dataSrc = getDataSrc())
            {
                let dataDest = dataSrc == CAT_FLD_SRC_COMB ? CAT_FLD_SRC_BASE : dataSrc;
                let fldKeyPrefix = (dataDest == CAT_FLD_SRC_BASE) ? [] : [dataDest];
                let fldPath = fldKeyPrefix.concat(path);
                let targetObj = catRec;
                while (fldPath.length > 1)
                {
                    let key = fldPath.shift();
                    if (!(key in targetObj))
                    {
                        // Initialise...
                        targetObj[key] = {};
                    }
                    targetObj = targetObj[key];
                }
                let targetKey = fldPath.shift();
                if (value == null)
                {
                    delete targetObj[targetKey];
                }
                else
                {
                    targetObj[targetKey] = value;
                }

                return true;
            }

            // Sets the value of the field located at the specified path.
            // The value is specified as a string which is parsed and stored as
            // a list.
            function setListFldVal(catRec, path, valueStr, dataSrc)
            {
                let value = null;
                if (valueStr)
                {
                    value = (valueStr.split(LIST_SEP)).map(function(comp) {return String.prototype.trim.apply(comp);});
                }
                return setFldVal(catRec, path, value, dataSrc);
            }

            // Sets a field value for the specified column.
            function setFldValByColId(catRec, colId, value, dataSrc = getDataSrc())
            {
                switch (colId)
                {
                    case CatColEnum.COL_PURCH_DATE:
                    case CatColEnum.COL_ARR_DATE:
                        return setDateFld(catRec, catColDefs[colId].catRecPath, value, CAT_FLD_SRC_BASE);

                    case CatColEnum.COL_SURNAME:
                        return setAuthorNames(catRec, NameEnum.NAME_SUR, value, dataSrc);

                    case CatColEnum.COL_GIVEN_NAMES:
                        return setAuthorNames(catRec, NameEnum.NAME_GIVEN, value, dataSrc);

                    case CatColEnum.COL_TITLE:
                        return setTitle(catRec, value, dataSrc);

                    case CatColEnum.COL_PUB_NAME:
                    case CatColEnum.COL_PUB_PLACE:
                        return setListFldVal(catRec, catColDefs[colId].catRecPath, value, dataSrc);

                    default:
                        if (catColDefs[colId].catRecPath)
                        {
                            let catRecDataSrc = catColDefs[colId].allSrcs ? dataSrc : CAT_FLD_SRC_BASE;
                            return setFldVal(catRec, catColDefs[colId].catRecPath, value, catRecDataSrc);
                            break;
                        }
                }

                return false;
            }

            // Sets a flag
            function setFlag(catRec, flagPos)
            {
                let flags = getFldVal(catRec, [CAT_FLD_FLAGS], CAT_FLD_SRC_BASE, 0);
                flags |= (1 << flagPos);
                setFldVal(catRec, [CAT_FLD_FLAGS], flags, CAT_FLD_SRC_BASE);
            }

            // Clears a flag
            function clearFlag(catRec, flagPos)
            {
                let flags = getFldVal(catRec, [CAT_FLD_FLAGS], CAT_FLD_SRC_BASE, 0);
                flags |= ~(1 << flagPos);
                setFldVal(catRec, [CAT_FLD_FLAGS], flags, CAT_FLD_SRC_BASE);
            }

            // Checks if a flag is set
            function isFlagSet(catRec, flagPos)
            {
                return (getFldVal(catRec, [CAT_FLD_FLAGS], CAT_FLD_SRC_BASE, 0) & (1 << flagPos));
            }

            // Format a field as a currency string
            function formatAsCurrency(fldParams)
            {
                priceString = null;

                if (fldParams.value)
                {
                    priceString = Number.parseFloat(fldParams.value).toFixed(2);
                    currency = getFldVal(fldParams.data, [CAT_FLD_CURRENCY], CAT_FLD_SRC_BASE);
                    if (currency)
                    {
                        if (currency == "VND")
                        {
                            priceString += CURRENCY_SYMBOLS[currency];
                        }
                        else
                        {
                            priceString = CURRENCY_SYMBOLS[currency] + priceString;
                        }
                    }
                }

                return (priceString);
            }

            function formatAsMass(mass)
            {
                return (Number.parseFloat(mass).toFixed(3));
            }

            function getTotalPriceFld(catRec)
            {
                let totalPriceFld = {};

                let price = getFldValByColId(catRec, CatColEnum.COL_PURCH_PRICE);
                let shippingPrice = getFldValByColId(catRec, CatColEnum.COL_SHIP_PRICE);

                if ((price || !isNaN(price)) && (shippingPrice || !isNaN(price)))
                {
                    let totalPrice = 0;
                    if (price)
                    {
                        totalPrice += parseFloat(price);
                    }

                    if (shippingPrice)
                    {
                        totalPrice += parseFloat(shippingPrice);
                    }

                    totalPriceFld[FLD_SRC] = CAT_FLD_SRC_BASE;
                    totalPriceFld[FLD_VAL] = totalPrice;
                }

                return totalPriceFld;
            }

            //
            // Retrieves the author's surname or given names
            //
            function getAuthorNamesFld(catRec, nameType, dataSrc)
            {
                let authFld = getFld(catRec, [CAT_FLD_AUTHORS], dataSrc);
                let authData = authFld[FLD_VAL];
                namesString = "";

                if (authData)
                {
                    for (authIdx = 0; authIdx < authData.length; authIdx++)
                    {
                        if (namesString)
                        {
                            namesString += AUTH_SEP + " ";
                        }
                        if (nameType == NameEnum.NAME_SUR)
                        {
                            if (CAT_FLD_AUTHOR_SURNAME in authData[authIdx])
                            {
                                namesString += authData[authIdx][CAT_FLD_AUTHOR_SURNAME];
                            }
                        }
                        else if (nameType == NameEnum.NAME_GIVEN)
                        {
                            if (CAT_FLD_AUTHOR_GIVEN_NAMES in authData[authIdx])
                            {
                                namesString += authData[authIdx][CAT_FLD_AUTHOR_GIVEN_NAMES].join(" ");
                            }
                        }
                    }
                }
                authFld[FLD_VAL] = namesString;
                return authFld;
            }

            //
            // Sets the author's surname or given names
            //
            function setAuthorNames(catRec, nameType, nameVal, dataSrc)
            {
                // Copy existing authors field to work with below
                let authData = JSON.parse(JSON.stringify(getFldVal(catRec, [CAT_FLD_AUTHORS], dataSrc)));
                if (!authData)
                {
                    authData = [];
                }

                // List of new names, filtering out any empty strings
                //let newNames = params.newValue ? (params.newValue.split(AUTH_SEP)).map(function(comp) {return String.prototype.trim.apply(comp);}) : [];
                let newNames = nameVal ? (nameVal.split(AUTH_SEP)).map(function(comp) {return String.prototype.trim.apply(comp);}) : [];
                newNames = newNames.filter(function(name) { return name && name.length > 0; });

                // Name of the field to update
                let nameField = (nameType == NameEnum.NAME_SUR) ? CAT_FLD_AUTHOR_SURNAME : CAT_FLD_AUTHOR_GIVEN_NAMES;

                // Delete existing names beyond the length of the new list
                for (let authIdx = newNames.length; authIdx < authData.length; authIdx++)
                {
                    delete(authData[authIdx][nameField]);
                }

                // Replace existing names with new ones
                for (let nameIdx = 0; nameIdx < newNames.length && nameIdx < authData.length; nameIdx++)
                {
                    authData[nameIdx][nameField] = (nameType == NameEnum.NAME_SUR) ? newNames[nameIdx] : newNames[nameIdx].split(NAME_SEP);
                }

                // Add names beyond the length of the original list
                for (let nameIdx = authData.length; nameIdx < newNames.length; nameIdx++)
                {
                    let newAuth = {};
                    if (nameType == NameEnum.NAME_SUR)
                    {
                        newAuth[CAT_FLD_AUTHOR_SURNAME] = newNames[nameIdx];
                    }
                    else
                    {
                        newAuth[CAT_FLD_AUTHOR_GIVEN_NAMES] = newNames[nameIdx].split(NAME_SEP);
                    }
                    authData.push(newAuth);
                }

                // Final clean up:
                //  Remove empty authors fields
                //  Set authData to null if it is now empty
                authData = authData.filter(function(auth) { return Object.keys(auth).length > 0; });
                if (authData.length == 0)
                {
                    authData = null;
                }

                return setFldVal(catRec, [CAT_FLD_AUTHORS], authData, dataSrc);
            }

            //
            // Retrieves the title and subtitle as a field with a single string value
            //
            function getTitleFld(catRec, dataSrc)
            {
                let titleFld = getFld(catRec, [CAT_FLD_TITLE], dataSrc);
                let titleSrc = titleFld[FLD_SRC];
                let titleVal = titleFld[FLD_VAL];

                if (titleSrc && titleVal)
                {
                    // Ensure the title and subtitle come from the same source
                    let subtitleFld = getFld(catRec, [CAT_FLD_SUBTITLE], titleSrc);
                    let subtitleSrc = subtitleFld[FLD_SRC];
                    let subtitleVal = subtitleFld[FLD_VAL];

                    if (subtitleSrc && subtitleVal)
                    {
                        titleVal += TITLE_SEP + " " + subtitleVal;
                    }
                }
                titleFld[FLD_VAL] = titleVal;
                return titleFld;
            }

            //
            // Sets the title and subtitle
            //
            function setTitle(catRec, titleStr, dataSrc = getDataSrc())
            {
                let titleComponents = [];
                if (titleStr)
                {
                    titleComponents = (titleStr.split(TITLE_SEP)).map(function(comp) {return String.prototype.trim.apply(comp);});
                }
                // Title = portion of string up to the first title separator,
                // Subtitle = remainder of string
                let title           = titleComponents.length > 0 ? titleComponents.shift() : null;
                let subtitle        = titleComponents.length > 0 ? titleComponents.join(TITLE_SEP + " ") : null;
                return (setFldVal(catRec, [CAT_FLD_TITLE], title, dataSrc) &&
                        setFldVal(catRec, [CAT_FLD_SUBTITLE], subtitle, dataSrc));
            }


            function getMassFld(catRec, dataSrc)
            {
                let massFld  = getFld(catRec, [CAT_FLD_DIM, CAT_FLD_DIM_MASS], dataSrc);
                if (massFld[FLD_VAL])
                {
                    let mass    = parseFloat(massFld[FLD_VAL]);
                    let massSrc = massFld[FLD_SRC];
                    let units = getFldVal(catRec, [CAT_FLD_DIM, CAT_FLD_DIM_MASS_UNITS], massSrc);
                    if (units)
                    {
                        switch (units)
                        {
                            case "ounces":
                            {
                                mass *= OZ_TO_KG;
                                break;
                            }
                            case "pounds":
                            {
                                mass *= LB_TO_KG;
                                break;
                            }
                            default:
                            {
                                mass *= G_TO_KG;
                                break;
                            }
                        }
                    }
                    massFld[FLD_VAL] = mass;
                }

                return massFld;
            }

            function getColTooltip(params)
            {
                let tooltip = null;
                switch (params.colDef.colId)
                {
                    case CatColEnum.COL_SYNCH_STATUS:
                        let lastSynchTime = getFldVal(params.data, [CAT_FLD_OPENLIB_SYNCH_TIME], CAT_FLD_SRC_BASE);
                        if (lastSynchTime)
                        {
                            tooltip = "Last synched: " + lastSynchTime;
                        }
                        break;

                    default:
                        if (getDataSrc() == CAT_FLD_SRC_COMB)
                        {
                            let fld = getFldByColId(params.data, params.colDef.colId);
                            tooltip = fld[FLD_SRC] ? "Data source: " + fld[FLD_SRC] : null;
                        }
                        break;
                }
                return tooltip;
            }

            // Checks if a candidate ISBN is valid, i.e. matches the relevant
            // pattern for the required number of digits
            function isISBNValid(isbnCandidate, requiredDigits)
            {
                let valid = false;
                if (requiredDigits == ISBN10_DIGITS || requiredDigits == ISBN13_DIGITS)
                {
                    let isbnRegexMatch = requiredDigits == ISBN10_DIGITS ? REGEX_ISBN10.test(isbnCandidate) : REGEX_ISBN13.test(isbnCandidate);
                    valid = isbnRegexMatch && (calcISBNCheckDigit(isbnCandidate) == isbnCandidate[isbnCandidate.length - 1]);
                }
                return valid;
            }

            // Computes the expected check digit for a candidate ISBN, using
            // steps described at https://bisg.org/page/conversionscalculat
            function calcISBNCheckDigit(isbnCandidate)
            {
                let checkDigit = -1;  // Initialise to an invalid digit
                if (REGEX_ISBN10.test(isbnCandidate))
                {
                    checkDigit = 0;
                    for (let idx = 0; idx < ISBN10_DIGITS - 1; idx++)
                    {
                        checkDigit += (ISBN10_MAX_DIGIT_WEIGHT - idx) * parseInt(isbnCandidate[idx]);
                    }
                    checkDigit %= ISBN10_MOD_FACTOR;
                    if (checkDigit > 0)
                    {
                        checkDigit = ISBN10_MOD_FACTOR - checkDigit;
                    }
                    return checkDigit < 10 ? checkDigit.toString() : "X";
                }
                else if (REGEX_ISBN13.test(isbnCandidate))
                {
                    checkDigit = 0
                    for (let idx = 0; idx < ISBN13_DIGITS - 1; idx++)
                    {
                        if (idx % 2 == 0)
                        {
                            checkDigit += parseInt(isbnCandidate[idx]);
                        }
                        else
                        {
                            checkDigit += 3 * parseInt(isbnCandidate[idx]);
                        }
                    }
                    checkDigit = ISBN13_MOD_FACTOR - checkDigit % ISBN13_MOD_FACTOR;
                    return checkDigit < 10 ? checkDigit.toString() : "0";
                }
                return checkDigit.toString();
            }

            // Converts between ISBN formats
            function convISBN(isbn)
            {
                let isbnConv = null;
                if (REGEX_ISBN10.test(isbn) || REGEX_ISBN13.test(isbn))
                {
                    if (REGEX_ISBN10.test(isbn))
                    {
                        isbnConv = ISBN13_PREFIX + isbn;
                    }
                    else if (REGEX_ISBN13.test(isbn))
                    {
                        isbnConv = isbn.replace(ISBN13_PREFIX, "");
                    }
                    isbnConv = isbnConv.substr(0, isbnConv.length - 1) + calcISBNCheckDigit(isbnConv);
                }
                return isbnConv;
            }

            // Sets a date field
            function setDateFld(catRec, path, dateStr, dataSrc)
            {
                let dateComponents = null;
                if (dateStr)
                {
                    dateComponents = parseDate(dateStr, false);
                }
                setFldVal(catRec, path, dateComponents, dataSrc);
            }

            function renderDateFld(fldParams)
            {
                let dateObj = fldParams.value;
                if (dateObj)
                {
                    let cellString = getDateString(dateObj);
                    return markFldValidity(fldParams, cellString);
                }
            }

            // Checks if a given catalogue record field's contents are valid:
            // validation steps depend on the field's expected data type, etc.
            function isFldValid(fldParams)
            {
                let valid = true;
                let fldColId = fldParams.colDef.colId;
                switch (fldColId)
                {
                    case CatColEnum.COL_ISBN_13:
                    case CatColEnum.COL_ISBN_10:
                        let isbnCandidate = fldParams.value;
                        if (isbnCandidate)
                        {
                            // The ISBN field must match the relevant pattern
                            // and have a sensible check digit
                            let requiredDigits = fldColId == CatColEnum.COL_ISBN_13 ? ISBN13_DIGITS : ISBN10_DIGITS;
                            valid = isISBNValid(isbnCandidate, requiredDigits);
                        }
                        break;

                    case CatColEnum.COL_PURCH_DATE:
                    case CatColEnum.COL_ARR_DATE:
                        valid = isDateValid(fldParams.value);
                        break;

                    case CatColEnum.COL_PURCH_PRICE:
                    case CatColEnum.COL_SHIP_PRICE:
                        let priceCandidate = fldParams.value;
                        if (priceCandidate)
                        {
                            valid = !isNaN(priceCandidate);
                        }
                        break;

                    default:
                        break;
                }

                return valid;
            }

            function markFldValidity(fldParams, cellString)
            {
                return isFldValid(fldParams) ? cellString : "<span class='cat-invalid-data'>" + cellString + "</span>";
            }
        </script>
    </body>
</html>
