<!DOCTYPE html>
<html>
    <head>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.css"/>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>

        <script src="https://unpkg.com/@ag-grid-enterprise/all-modules/dist/ag-grid-enterprise.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
        <link rel="stylesheet" href="https://unpkg.com/ag-grid-enterprise/dist/styles/ag-grid.css">
        <link rel="stylesheet" href="https://unpkg.com/ag-grid-enterprise/dist/styles/ag-theme-balham.css">
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
        <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

        <script type="text/javascript" src="bookcat_comp.js"></script>
        <script type="text/javascript" src="bookcat_utils.js"></script>
    </head>
    <style>
        .main-div
        {
            height: 550px;
            width:  100%;
        }

        .info
        {
            font-size:  large;
            font-style: italic;
        }

        .panel-heading
        {
            font-size:  medium;
        }

        .panel-collapse
        {
            margin: 0.5em 0em 0em;
        }

        .grid-container
        {
            display: grid;
            grid-template-columns: auto;
            text-align: center;
        }

        .grid-settings
        {
            padding:    2em 0.5em 0.5em;
        }

        .invalid-data
        {
            background-color:   red;
        }

        .cat-dropdown
        {
            font-size:  inherit;
        }

        .cat-dropdown-item
        {
            padding:    0.25em 0em 0.5em 1em;
        }

        .hidden-date-input
        {
            height: 0;
            width: 0;
            border: 0
        }
    </style>
    <body>
        <div id="testDiv"></div>

        <div id="catGrid" class="main-div ag-theme-balham container-fluid">
            <h2>Ex libris ... munchi</h2>
            <div class="panel-group">
                <div id="divCatInfo" class="info"></div>
                <div class="panel-heading">
                    <!-- Click to show/hide catalogue file selection and editing options -->
                    <a data-toggle="collapse" href="#divCatSelectForm">Catalogue file options</a>
                </div>
                <div id="divCatSelectForm" class="panel-collapse collapse">
                    <div class="panel-body">
                        <form id="catDataForm" class="form-inline">
                            <span style="padding:0em 1em 0em 0em;">
                                <button type="button" id="btnNew" class="btn btn-primary">Create new catalogue</button>
                            </span>
                            <button type="button" id="btnLoadDefault" class="btn btn-primary">Load default catalogue</button>
                            <span style="padding:0em 2em;">
                                <input type="file" id="fileinputCat" class="form-control">
                                <button type="button" id="btnLoad" class="btn btn-primary">Load catalogue</button>
                            </span>
                            <button type="button" id="btnProcessUpdates" class="btn btn-primary">Save updated catalogue</button>
                        </form>
                        <hr/>
                    </div>
                </div>
            </div>
            <div class="grid-settings">
                <div class="form-check-inline">
                    <label class="form-check-label">Data source:</label>
                </div>
                <div class="form-check-inline">
                    <label class="form-check-label" for="srcComb">
                        <input type="radio" class="form-check-input" id="srcComb" name="optSrc" value="combined" checked>combined
                    </label>
                </div>
                <div class="form-check-inline">
                    <label class="form-check-label" for="srcMC">
                        <input type="radio" class="form-check-input" id="srcMC" name="optSrc" value="base">munchi
                    </label>
                </div>
                <div class="form-check-inline">
                    <label class="form-check-label" for="srcOL">
                        <input type="radio" class="form-check-input" id="srcOL" name="optSrc" value="openlib">openlib
                    </label>
                </div>
                <div class="form-check-inline">
                    <label class="form-check-label" for="srcAma">
                        <input type="radio" class="form-check-input" id="srcAma" name="optSrc" value="amazon">amazon
                    </label>
                </div>
                <div class="form-inline">
                    <div class="dropdown dropright">
                        <button type="button" class="dropdown-toggle" data-toggle="dropdown">
                            Add catalogue record
                        </button>
                        <div class="dropdown-menu cat-dropdown" style="padding: 0.5em">
                            <span class="dropdown-item cat-dropdown-item" id="itmAddCatEnd">At end of catalogue</span>
                            <span class="dropdown-item cat-dropdown-item" id="itmAddCatBeg">At start of catalogue</span>
                            <span class="dropdown-item cat-dropdown-item" id="itmAddAfterSel">After selected record</span>
                            <span class="dropdown-item cat-dropdown-item" id="itmAddBeforeSel">Before selected record</span>
                        </div>
                    </div>
                    <button type="button" id="btnResynch" style="margin: 0em 1em;">
                        (Re)synch with openlib
                    </button>
                </div>
            </div>
        </div>

        <script type="text/javascript" charset="utf-8">
            // ISBN handling
            const REGEX_ISBN13              = new RegExp(/^978[0-9]{9}[0-9X]$/);
            const REGEX_ISBN10              = new RegExp(/^[0-9]{9}[0-9X]$/);
            const ISBN13_PREFIX             = "978";
            const ISBN13_DIGITS             = 13;
            const ISBN13_MOD_FACTOR         = 10;
            const ISBN10_DIGITS             = 10;
            const ISBN10_MAX_DIGIT_WEIGHT   = 10;
            const ISBN10_MOD_FACTOR         = 11;

            // Date handling
            const REGEX_YEAR    = new RegExp(/^[1-9][0-9]*$/);
            const REGEX_MONTH   = new RegExp(/^(1[0-2]|0?[1-9])$/);
            const REGEX_DAY     = new RegExp(/^(0?[1-9]|[1-2][0-9]|3[01])$/);
            const YEAR_MIN  = 1;    // Not dealing with BCE items... :)
            const MONTH_MIN = 1;
            const MONTH_MAX = 12;
            const DAY_MIN   = 1;
            const STD_MONTH_LENGTHS =
            {
                1:  31,
                2:  28,
                3:  31,
                4:  30,
                5:  31,
                6:  30,
                7:  31,
                8:  31,
                9:  30,
                10: 31,
                11: 30,
                12: 31
            };
            const FEB_LEAP_YEAR_DAYS = 29;

            // Mapping between currency codes and symbols
            const CURRENCY_SYMBOLS =
            {
                "AUD":  "$",
                "EUR":  "€",
                "GBP":  "£",
                "SGD":  "$SGD",
                "USD":  "$US",
                "VND":  "₫",
                "":     ""
            };

            // Dimension conversions
            const IN_TO_CM  = 2.54
            const LB_TO_OZ  = 16;
            const OZ_TO_KG  = 0.028;
            const LB_TO_KG  = LB_TO_OZ * OZ_TO_KG;
            const G_TO_KG   = 0.001;

            const BCK_FLAG_BIT_OPENLIB_SYNCED   = 0;
            const BCK_FLAG_BIT_IN_OPENLIB       = 1;

            const FLD_ID_MIN                    = 1;

            // Catalogue field keys
            const CAT_FLD_SRC_BASE              = "base";
            const CAT_FLD_SRC_AMAZON            = "amazon";
            const CAT_FLD_SRC_OPENLIB           = "openlib";
            const CAT_FLD_SRC_COMB              = "combined";

            const CAT_FLD_ID                    = "id";
            const CAT_FLD_ISBN13                = "isbn_13";
            const CAT_FLD_ISBN10                = "isbn_10";

            const CAT_FLD_PURCH_DATE            = "purchase_date";
            const CAT_FLD_ARR_DATE              = "arrival_date";
            const CAT_FLD_DATE_YEAR             = "year";
            const CAT_FLD_DATE_MONTH            = "month";
            const CAT_FLD_DATE_DAY              = "day";

            const CAT_FLD_SELLER                = "seller";
            const CAT_FLD_SELLER_BRANCH         = "seller_branch";
            const CAT_FLD_PURCHASER             = "purchaser";
            const CAT_FLD_PURCH_PRICE           = "purchase_price";
            const CAT_FLD_SHIP_PRICE            = "shipping_price";
            const CAT_FLD_CURRENCY              = "purchase_currency";
            const CAT_FLD_NUM_IN_ORDER          = "number_in_order";
            const CAT_FLD_AUTHORS               = "authors";
            const CAT_FLD_AUTHOR_SURNAME        = "surname";
            const CAT_FLD_AUTHOR_GIVEN_NAMES    = "given_names";
            const CAT_FLD_TITLE                 = "title";
            const CAT_FLD_SUBTITLE              = "subtitle";
            const CAT_FLD_PUBLISHERS            = "publishers";
            const CAT_FLD_PUBLISH_PLACES        = "publish_places";
            const CAT_FLD_FLAGS                 = "flags";
            const CAT_FLD_DIM                   = "dimensions";
            const CAT_FLD_DIM_HEIGHT            = "height";
            const CAT_FLD_DIM_WIDTH             = "width";
            const CAT_FLD_DIM_THICKNESS         = "thickness";
            const CAT_FLD_DIM_LENGTH            = "length";
            const CAT_FLD_DIM_MASS              = "mass";
            const CAT_FLD_DIM_MASS_UNITS        = "mass_units";
            const CAT_FLD_LOCATION              = "location";
            const CAT_FLD_COVER_REQUIRED        = "cover_required";
            const CAT_FLD_NOTES                 = "notes";
            const CAT_FLD_ELEC_FORMAT           = "electronic_format";
            const CAT_FLD_INFO_URL              = "info_url";

            const CAT_FLD_OPENLIB_SYNCH_TIME    = "openlib_synch_time";

            // Open library field keys
            const OLK_DETAILS           = "details";
            const OLK_AUTHORS           = "authors"
            const OLK_AUTHOR_NAME       = "name"
            const OLK_KEY               = "key";
            const OLK_FORMAT            = "physical_format";
            const OLK_DIMENSIONS        = "physical_dimensions";
            const OLK_WEIGHT            = "weight";
            const OLK_PAGES             = "number_of_pages";
            const OLK_PUBLISHERS        = "publishers";
            const OLK_PUBLISH_PLACES    = "publish_places";
            const OLK_PUBLISH_DATE      = "publish_date";
            const OLK_SUBTITLE          = "subtitle";
            const OLK_TITLE             = "title";
            const OLK_URL               = "info_url";

            // Faking an enum
            const NameEnum =
            {
                "NAME_SUR":     0,
                "NAME_GIVEN":   1
            };
            Object.freeze(NameEnum);

            // Delimiters in fields that represent lists
            const DATE_SEP  = "-";
            const AUTH_SEP  = ";";
            const TITLE_SEP = ":";
            const PUB_SEP   = ";";

            const REGEX_EXT         = new RegExp(/[.][^.]*$/);  // File extension regular expression
            const UPDATED_CAT_EXT   = ".updated";

            // Default column options
            const defaultCatCol =
            {
                sortable:       true,
                filter:         true,
                //floatingFilter: true,
                filterParams:
                {
                    resetButton: true
                },
                resizable:      true,
                editable:       true,
                menuTabs:       ["filterMenuTab", "columnsMenuTab"]
            };

            // Column header names
            const COL_HDR_ID                = "Cat ID";
            const COL_GRP_HDR_SYNCH         = "Openlib synch status";
            const COL_HDR_RESYNCH           = "(Re)synch";
            const COL_HDR_SYNCH_STATUS      = "Synched";
            const COL_HDR_IN_OPENLIB        = "In openlib";
            const COL_GRP_HDR_PURCHASE      = "Purchase Details";
            const COL_HDR_PURCH_DATE        = "Purchase Date";
            const COL_HDR_ARR_DATE          = "Arrival Date";
            const COL_HDR_SELLER            = "Seller";
            const COL_HDR_SELLER_BRANCH     = "Seller Branch";
            const COL_HDR_PURCHASER         = "Purchaser";
            const COL_HDR_NUM_IN_ORDER      = "#";
            const COL_HDR_CURRENCY          = "Currency";
            const COL_HDR_PURCH_PRICE       = "Price";
            const COL_HDR_SHIP_PRICE        = "Shipping";
            const COL_HDR_TOTAL_PRICE       = "Total Price";
            const COL_GRP_HDR_IDENTIFIERS   = "Identifiers";
            const COL_HDR_ISBN_13           = "ISBN 13";
            const COL_HDR_ISBN_10           = "ISBN 10";
            const COL_GRP_HDR_AUTHOR        = "Author/Editor";
            const COL_HDR_SURNAME           = "Surname";
            const COL_HDR_GIVEN_NAMES       = "Given Name(s)";
            const COL_HDR_TITLE             = "Title";
            const COL_GRP_HDR_PUB           = "Publiser Details";
            const COL_HDR_PUB_NAME          = "Name(s)";
            const COL_HDR_PUB_PLACE         = "Place(s)";
            const COL_HDR_PUB_DATE          = "Date";
            const COL_GRP_HDR_PHYS          = "Physical Details";
            const COL_HDR_DIM_HEIGHT        = "H (cm)";
            const COL_HDR_DIM_WIDTH         = "W (cm)";
            const COL_HDR_DIM_THICKNESS     = "T (cm)";
            const COL_HDR_DIM_LENGTH        = "Length (pp)";
            const COL_HDR_DIM_MASS          = "Mass (kg)";
            const COL_HDR_LOCATION          = "Shelf Location";
            const COL_HDR_COVER_REQUIRED    = "Cover Required?";
            const COL_HDR_NOTES             = "Notes";
            const COL_HDR_ELEC_FORMAT       = "Electronic Copy";

            // Column definitions
            let bookColumns =
            [
                {
                    headerName:     COL_HDR_ID,
                    headerTooltip:  "Master identifier for the catalogue record (automatically generated)",
                    field:          CAT_FLD_ID,
                    editable:       false,
                    filter:         "agNumberColumnFilter"
                },
                {
                    headerName: COL_GRP_HDR_SYNCH,
                    children:
                    [
                        {
                            headerName:         COL_HDR_RESYNCH,
                            headerCheckboxSelection:                true,   // Allow selection of all rows
                            headerCheckboxSelectionFilteredOnly:    true,   // included by filtering
                            checkboxSelection:  true,
                            headerTooltip:      "Check for updated openlib details",
                            filter:             false
                        },
                        {
                            headerName:     COL_HDR_SYNCH_STATUS,
                            headerTooltip:  "Is the record synched with openlib?",
                            editable:       false,
                            valueGetter: function(params)
                            {
                                return isFlagSet(params.data, BCK_FLAG_BIT_OPENLIB_SYNCED) ? "✓" : "";
                            },
                            tooltipValueGetter: function(params)
                            {
                                let lastSynchTime = getFld(params.data, [CAT_FLD_OPENLIB_SYNCH_TIME], CAT_FLD_SRC_BASE);
                                if (lastSynchTime)
                                {
                                    return "Last synched: " + lastSynchTime;
                                }
                            }
                        },
                        {
                            headerName: COL_HDR_IN_OPENLIB,
                            headerTooltip: "Book exists in openlib",
                            valueGetter: function(params)
                            {
                                return isFlagSet(params.data, BCK_FLAG_BIT_IN_OPENLIB) ? "✓" : "";
                            },
                            editable:       false
                        }
                    ]
                },
                {
                    headerName: COL_GRP_HDR_PURCHASE,
                    children:
                    [
                        {
                            headerName: COL_HDR_PURCH_DATE,
                            cellEditor: "datePicker",
                            editable: true,
                            field:  CAT_FLD_PURCH_DATE,
                            valueSetter: function(params)
                            {
                                setDateFld(params, [CAT_FLD_PURCH_DATE]);
                            },
                            cellRenderer: function(params)
                            {
                                return renderDateFld(params);
                            },
                            filter: "dateFilterComponent",
                            filterParams:
                            {
                                comparator: function(filterDate, recFld)
                                {
                                    return compareDates(filterDate, recFld);
                                }
                            }
                        },
                        {
                            headerName: COL_HDR_ARR_DATE,
                            cellEditor: "datePicker",
                            editable: true,
                            valueGetter: function(params)
                            {
                                arrDate = getFld(params.data, [CAT_FLD_ARR_DATE], CAT_FLD_SRC_BASE);
                                if (!arrDate)
                                {
                                    arrDate = getFld(params.data, [CAT_FLD_PURCH_DATE], CAT_FLD_SRC_BASE);
                                }
                                return arrDate;
                            },
                            valueSetter: function(params)
                            {
                                setDateFld(params, [CAT_FLD_ARR_DATE]);
                            },
                            cellRenderer: function(params)
                            {
                                return renderDateFld(params);
                            },
                            filter: "dateFilterComponent",
                            filterParams:
                            {
                                comparator: function(filterDate, recFld)
                                {
                                    return compareDates(filterDate, recFld);
                                }
                            },
                            hide: true
                        },
                        {headerName: COL_HDR_SELLER, field: CAT_FLD_SELLER},
                        {headerName: COL_HDR_SELLER_BRANCH, field: CAT_FLD_SELLER_BRANCH, hide: true},
                        {headerName: COL_HDR_PURCHASER, field: CAT_FLD_PURCHASER, hide: true},
                        {headerName: COL_HDR_NUM_IN_ORDER, field: CAT_FLD_NUM_IN_ORDER, hide: true},
                        {
                            headerName: COL_HDR_CURRENCY,
                            field: CAT_FLD_CURRENCY,
                            cellEditor: "agRichSelectCellEditor",
                            cellEditorParams:
                            {
                                values: Object.keys(CURRENCY_SYMBOLS)
                            },
                            onCellValueChanged: function(params)
                            {
                                gridOptions.api.redrawRows();
                            },
                            hide: true
                        },
                        {
                            headerName: COL_HDR_PURCH_PRICE,
                            field: CAT_FLD_PURCH_PRICE,
                            cellRenderer: function(params)
                            {
                                cellString = isFldValid(params) ? formatAsCurrency(params) : params.value;
                                return markFldValidity(params, cellString);
                            },
                            filter: "agNumberColumnFilter"
                        },
                        {
                            headerName: COL_HDR_SHIP_PRICE,
                            field: CAT_FLD_SHIP_PRICE,
                            cellRenderer: function(params)
                            {
                                cellString = isFldValid(params) ? formatAsCurrency(params) : params.value;
                                return markFldValidity(params, cellString);
                            },
                            filter: "agNumberColumnFilter",
                            hide: true
                        },
                        {
                            headerName: COL_HDR_TOTAL_PRICE,
                            valueGetter: function(params)
                            {
                                let totalPrice = null;

                                let price = getFld(params.data, [CAT_FLD_PURCH_PRICE], CAT_FLD_SRC_BASE);
                                let shippingPrice = getFld(params.data, [CAT_FLD_SHIP_PRICE], CAT_FLD_SRC_BASE);

                                if ((price || !isNaN(price)) && (shippingPrice || !isNaN(price)))
                                {
                                    totalPrice = 0;
                                    if (price)
                                    {
                                        totalPrice += parseFloat(price);
                                    }

                                    if (shippingPrice)
                                    {
                                        totalPrice += parseFloat(shippingPrice);
                                    }
                                }

                                return totalPrice;
                            },
                            cellRenderer: function(params)
                            {
                                return (formatAsCurrency(params));
                            },
                            editable: false,
                            filter:   "agNumberColumnFilter"
                        },
                    ]
                },
                {
                    headerName: COL_GRP_HDR_AUTHOR,
                    suppressMenu: false,
                    children:
                    [
                        {
                            headerName: COL_HDR_SURNAME,
                            valueGetter: function(params)
                            {
                                return getAuthorNames(params, NameEnum.NAME_SUR);
                            },
                            valueSetter: function(params)
                            {
                                return setAuthorNames(params, NameEnum.NAME_SUR);
                            }
                        },
                        {
                            headerName: COL_HDR_GIVEN_NAMES,
                            valueGetter: function(params)
                            {
                                return getAuthorNames(params, NameEnum.NAME_GIVEN);
                            },
                            valueSetter: function(params)
                            {
                                return setAuthorNames(params, NameEnum.NAME_GIVEN);
                            }

                        }
                    ]
                },
                {
                    headerName: COL_GRP_HDR_IDENTIFIERS,
                    children:
                    [

                        {
                            headerName:     COL_HDR_ISBN_13,
                            headerToolTip:  "13 digit international standard book number",
                            field:          CAT_FLD_ISBN13,
                            cellRenderer: function(params)
                            {
                                let cellString = params.value;
                                return markFldValidity(params, cellString);
                            }
                        },
                        {
                            headerName:     COL_HDR_ISBN_10,
                            headerToolTip:  "10 digit international standard book number",
                            field:          CAT_FLD_ISBN10,
                            cellRenderer: function(params)
                            {
                                let cellString = params.value;
                                return markFldValidity(params, cellString);
                            }
                        },
                        {
                            headerName: COL_HDR_TITLE,
                            valueGetter: function(params)
                            {
                                let title       = getFld(params.data, [CAT_FLD_TITLE]);
                                let subtitle    = getFld(params.data, [CAT_FLD_SUBTITLE]);
                                if (subtitle)
                                {
                                    title += TITLE_SEP + " " + subtitle;
                                }
                                return title;
                            },
                            valueSetter: function(params)
                            {
                                // Split the input value into title and subtitle
                                let titleComponents = (params.newValue.split(TITLE_SEP)).map(function(comp) {return String.prototype.trim.apply(comp);});;
                                let title           = titleComponents.shift();
                                let subtitle        = titleComponents.length > 0 ? titleComponents.join(TITLE_SEP + " ") : null;
                                return (setFld(params.data, [CAT_FLD_TITLE], title) &&
                                    setFld(params.data, [CAT_FLD_SUBTITLE], subtitle));
                            },
                            cellRenderer: function(params)
                            {
                                let cellString = params.value;
                                let infoUrl = getFld(params.data, [CAT_FLD_INFO_URL], CAT_FLD_SRC_OPENLIB);
                                if (infoUrl)
                                {
                                    cellString = "<a href='" + infoUrl + "' target='_blank'>" + cellString + "</a>";
                                }
                                return cellString;
                            }
                        },
                    ]
                },
                {
                    headerName: COL_GRP_HDR_PUB,
                    children:
                    [
                        {
                            hide: false,
                            headerName: COL_HDR_PUB_NAME,
                            valueGetter: function(params)
                            {
                                let pubs        = getFld(params.data, [CAT_FLD_PUBLISHERS]);
                                let pubString   = pubs ? pubs.join(PUB_SEP + " ") : null;
                                return pubString;
                            },
                            valueSetter: function(params)
                            {
                                let pubs = null;
                                if (params.newValue)
                                {
                                    pubs = (params.newValue.split(PUB_SEP)).map(function(comp) {return String.prototype.trim.apply(comp);});
                                }
                                return(setFld(params.data, [CAT_FLD_PUBLISHERS], pubs));
                            }
                        },
                        {
                            headerName: COL_HDR_PUB_PLACE,
                            valueGetter: function(params)
                            {
                                let plcs        = getFld(params.data, [CAT_FLD_PUBLISH_PLACES]);
                                let plcString   = plcs ? plcs.join(PUB_SEP + " ") : null;
                                return plcString;
                            },
                            valueSetter: function(params)
                            {
                                let plcs = null;
                                if (params.newValue)
                                {
                                    plcs = (params.newValue.split(PUB_SEP)).map(function(comp) {return String.prototype.trim.apply(comp);});
                                }
                                return(setFld(params.data, [CAT_FLD_PUBLISH_PLACES], plcs));
                            },
                            hide: true
                        }
                    ]
                },
                {
                    headerName: COL_GRP_HDR_PHYS,
                    children:
                    [
                        {
                            headerName: COL_HDR_DIM_HEIGHT,
                            valueGetter: function(params)
                            {
                                return getFld(params.data, [CAT_FLD_DIM, CAT_FLD_DIM_HEIGHT]);
                            },
                            valueSetter: function(params)
                            {
                                return(setFld(params.data, [CAT_FLD_DIM, CAT_FLD_DIM_HEIGHT], params.newValue));
                            },
                            filter: "agNumberColumnFilter",
                            hide: true
                        },
                        {
                            headerName: COL_HDR_DIM_WIDTH,
                            valueGetter: function(params)
                            {
                                return getFld(params.data, [CAT_FLD_DIM, CAT_FLD_DIM_WIDTH]);
                            },
                            valueSetter: function(params)
                            {
                                return(setFld(params.data, [CAT_FLD_DIM, CAT_FLD_DIM_WIDTH], params.newValue));
                            },
                            filter: "agNumberColumnFilter",
                            hide: true
                        },
                        {
                            headerName: COL_HDR_DIM_THICKNESS,
                            valueGetter: function(params)
                            {
                                return getFld(params.data, [CAT_FLD_DIM, CAT_FLD_DIM_THICKNESS]);
                            },
                            valueSetter: function(params)
                            {
                                return(setFld(params.data, [CAT_FLD_DIM, CAT_FLD_DIM_THICKNESS], params.newValue));
                            },
                            filter: "agNumberColumnFilter",
                            hide: true
                        },
                        {
                            headerName: COL_HDR_DIM_LENGTH,
                            valueGetter: function(params)
                            {
                                return getFld(params.data, [CAT_FLD_DIM, CAT_FLD_DIM_LENGTH]);
                            },
                            valueSetter: function(params)
                            {
                                return(setFld(params.data, [CAT_FLD_DIM, CAT_FLD_DIM_LENGTH], params.newValue));
                            },
                            filter: "agNumberColumnFilter",
                            hide: true
                        },
                        {
                            headerName: COL_HDR_DIM_MASS,
                            valueGetter: function(params)
                            {
                                let mass    = null;
                                let rawMass = getFld(params.data, [CAT_FLD_DIM, CAT_FLD_DIM_MASS]);
                                if (rawMass)
                                {
                                    mass = parseFloat(rawMass);
                                    let units = getFld(params.data, [CAT_FLD_DIM, CAT_FLD_DIM_MASS_UNITS]);
                                    if (units)
                                    {
                                        switch (units)
                                        {
                                            case "ounces":
                                            {
                                                mass *= OZ_TO_KG;
                                                break;
                                            }
                                            case "pounds":
                                            {
                                                mass *= LB_TO_KG;
                                                break;
                                            }
                                            default:
                                            {
                                                mass *= G_TO_KG;
                                                break;
                                            }
                                        }
                                    }
                                }
                                return mass;
                            },
                            valueSetter: function(params)
                            {
                                return(setFld(params.data, [CAT_FLD_DIM, CAT_FLD_DIM_MASS], params.newValue));
                            },
                            cellRenderer: function(params)
                            {
                                if (params.value)
                                {
                                    cellString = formatAsMass(params.value);
                                    if (!isFldValid(params))
                                    {
                                    }
                                    return (formatAsMass(params.value));
                                }
                            },
                            filter: "agNumberColumnFilter",
                            hide: true
                        },
                        {headerName: COL_HDR_LOCATION, field: CAT_FLD_LOCATION},
                        {headerName: COL_HDR_COVER_REQUIRED, field: CAT_FLD_COVER_REQUIRED, hide: true},
                    ]
                },
                {headerName: COL_HDR_NOTES, field: CAT_FLD_NOTES},
                {headerName: COL_HDR_ELEC_FORMAT, field: CAT_FLD_ELEC_FORMAT, hide: true}
            ];

            // Default grid configuration (empty data)
            let gridOptions =
            {
                defaultColDef:          defaultCatCol,
                columnDefs:             bookColumns,

                rowSelection:           "multiple",
                rowDeselection:         true,           // Allow deselecting rows with Ctrl-click
                enableRangeSelection:   true,           // Allow multiple values in the same column to be selected/copied
                suppressRowTransform:   true,           // Allow row spanning
                onRowSelected: function(params)
                {
                    if (getFld(params.data, [CAT_FLD_FLAGS], CAT_FLD_SRC_BASE))
                    {
                        // Toggle selected item's openlib (re)synch flag
                        params.data.flags ^= (1 << BCK_FLAG_BIT_OPENLIB_SYNCED);
                    }
                },


                undoRedoCellEditing:    true,

                getContextMenuItems:    getCatContextMenu,

                components:
                {
                    dateFilterComponent: getDateFilterComponent(),
                    agDateInput: getDateComponent(),
                    datePicker: getDatePicker()
                },
                rowData:                []
            };

            let catFilename = "";   // Catalogue file name
            let catData     = [];   // Catalogue data array

            $(document).ready(function()
            {
                // Initialise the catalogue grid
                let gridDiv = document.querySelector("#catGrid");
                new agGrid.Grid(gridDiv, gridOptions);
                loadDefaultCat();

                // Load/display selected catalogue data
                $("#btnLoad").click(function()
                {
                    loadSelectedCat();
                });

                $("#fileinputCat").change(function()
                {
                    // Load catalogue data in response to file selection
                    loadSelectedCat();
                });

                $("#btnNew").click(function()
                {
                    // Clear existing data and repopulate the grid
                    catData.length = 0;
                    populateGrid(catData);
                });

                $("#btnLoadDefault").click(function()
                {
                    // Load catalogue data in response to button click
                    loadDefaultCat();
                });

                // Save a version of the catalogue file with selected items flagged
                // for resynch with openlib
                $("#btnProcessUpdates").click(function()
                {
                    let catDataString = JSON.stringify(catData, null, 4);
                    let updatedCatFile = new Blob([catDataString], {type: "text/plain;charset=UTF-8"});
                    let updatedCatFileElem = document.createElement("a");
                    updatedCatFileElem.href = URL.createObjectURL(updatedCatFile);

                    // Generate updated catalogue filename
                    let catFilenameExt  = REGEX_EXT.exec(catFilename);
                    let updatedCatFilename = catFilename.replace(catFilenameExt, UPDATED_CAT_EXT + catFilenameExt);
                    updatedCatFileElem.download = updatedCatFilename;

                    updatedCatFileElem.click();
                });

                // Toggle the catalogue data source
                $("[name='optSrc']").click(function()
                {
                    gridOptions.api.redrawRows();
                });

                // Add record at end of catalogue
                $("#itmAddCatEnd").click(function()
                {
                    addCatRec(getMaxGridIdx(), getMaxDataIdx(), getMaxRecId() + 1, true);
                });

                // Add record at beginning of catalogue
                $("#itmAddCatBeg").click(function()
                {
                    addCatRec(0, 0, getMinRecId(), false);
                });

                // Add record after first selected grid row
                $("#itmAddAfterSel").click(function()
                {
                    // Defaults if nothing is selected (add record at end)
                    let gridRefIdx  = getMaxGridIdx();
                    let dataRefIdx  = getMaxDataIdx();
                    let newId       = getMaxRecId() + 1;

                    let gridSelections = gridOptions.api.getSelectedNodes();
                    let firstGridSelection = gridSelections.length > 0 ? gridSelections[0] : null;
                    if (firstGridSelection)
                    {
                        gridRefIdx = firstGridSelection.rowIndex;
                        dataRefIdx = catData.indexOf(firstGridSelection.data);
                        newId = firstGridSelection.data[CAT_FLD_ID] + 1;
                    }

                    addCatRec(gridRefIdx, dataRefIdx, newId, true);
                });

                // Add record before first selected grid row
                $("#itmAddBeforeSel").click(function()
                {
                    // Defaults if nothing is selected (add record at beginning)
                    let gridRefIdx  = 0;
                    let dataRefIdx  = 0;
                    let newId       = getMinRecId();

                    let gridSelections = gridOptions.api.getSelectedNodes();
                    let firstGridSelection = gridSelections.length > 0 ? gridSelections[0] : null;
                    if (firstGridSelection)
                    {
                        gridRefIdx = firstGridSelection.rowIndex;
                        dataRefIdx = catData.indexOf(firstGridSelection.data);
                        newId = firstGridSelection.data[CAT_FLD_ID];
                    }

                    addCatRec(gridRefIdx, dataRefIdx, newId, false);
                });

                $("#btnResynch").click(function()
                {
                    synchSelectedRecs();
                });
            });

            // Loads the default catalogue
            function loadDefaultCat()
            {
                catFilename = "Books.cat";

                let xmlhttp = new XMLHttpRequest();
                xmlhttp.onreadystatechange = function()
                {
                    if (this.readyState == 4 && this.status == 200)
                    {
                        catData = JSON.parse(this.responseText);
                        populateGrid(catData);
                    }
                };
                xmlhttp.open("GET", catFilename, true);
                xmlhttp.send();
            }

            // Loads a selected catalogue
            function loadSelectedCat()
            {
                let fileinput, fileReader;

                // Parse file input element
                fileinput = document.getElementById("fileinputCat");
                if (!fileinput)
                {
                    alert("Couldn't find the catalogue file HTML element.");
                }
                else if (!fileinput.files)
                {
                    alert("This browser doesn't seem to support the `files` property of file inputs.");
                }
                else if (!fileinput.files[0])
                {
                    alert("Please select a catalogue file before clicking 'Load'");
                }
                else
                {
                    catFilename = fileinput.files[0].name;
                    catFile = fileinput.files[0];
                    fileReader = new FileReader();
                    fileReader.onload = receivedText;
                    fileReader.readAsText(catFile);
                }

                // Proceess catalogue file contents
                function receivedText(e)
                {
                    catData = JSON.parse(e.target.result);
                    populateGrid(catData);
                }
            }

            // Populate the catalogue grid
            function populateGrid(catData)
            {
                catData.sort(compareRecs);
                gridOptions.api.setRowData(catData);
                gridOptions.columnApi.autoSizeColumns();
                gridOptions.api.sizeColumnsToFit();

                document.getElementById("divCatInfo").innerHTML = "Displaying catalogue: '" + catFilename + "'";
            }

            // Defines the menu that appears when a cell is right-clicked
            function getCatContextMenu(params)
            {
                // Default items
                let menuItems =
                [
                    "copy",
                    "export",
                    {
                        name:   "Synch With Openlib",
                        action: function()
                        {
                            // Save grid selection(s)
                            let currSelectedNodes = gridOptions.api.getSelectedNodes();

                            // Set the clicked node as the sole selection
                            params.node.setSelected(true, true);

                            // Synch!
                            synchSelectedRecs();

                            // Restore grid selection(s)
                            currSelectedNodes.forEach(function(node)
                                {
                                    node.setSelected(true);
                                }
                            );
                        }
                    },
                    {
                        name:   "Delete",
                        action: function()
                        {
                            // Save grid selection(s)
                            let currSelectedNodes = gridOptions.api.getSelectedNodes();

                            // Set the clicked node as the sole selection
                            params.node.setSelected(true, true);

                            // Delete!
                            delSelectedRecs();

                            // Restore grid selection(s)
                            currSelectedNodes.forEach(function(node)
                                {
                                    node.setSelected(true);
                                }
                            );
                        }
                    },
                    "separator",
                    {
                        name:   "Synch Selected With Openlib",
                        action: function()
                        {
                            synchSelectedRecs();
                        }
                    },
                    {
                        name:   "Delete Selected",
                        action: function()
                        {
                            delSelectedRecs();
                        }
                    },
                    "separator",
                    "autoSizeAll",
                    "resetColumns",
                    {
                        name:   "Clear filters",
                        action: function()
                        {
                            gridOptions.api.setFilterModel(null);
                            gridOptions.api.onFilterChanged();
                        }
                    }
                ];

                let colId = params.column ? params.column.colId : null;
                switch (colId)
                {
                    case null:
                    {
                        break;
                    }

                    // For the ISBN13/10 columns, add an item for filling in
                    // the value by converting the counterpart ("source") ISBN
                    case CAT_FLD_ISBN13:
                    case CAT_FLD_ISBN10:
                    {
                        let isbnSourceName      = colId == CAT_FLD_ISBN13 ? COL_HDR_ISBN_10 : COL_HDR_ISBN_13;
                        let isbnSource          = colId == CAT_FLD_ISBN13 ? CAT_FLD_ISBN10 : CAT_FLD_ISBN13;
                        let isbnSourceDigits    = colId == CAT_FLD_ISBN13 ? ISBN10_DIGITS : ISBN13_DIGITS;
                        let menuItemAutofillISBN =
                        {
                            name: "Fill in based on " + isbnSourceName,

                            // Disable fill-in if the source ISBN is invalid
                            disabled: !isISBNValid(getFld(params.node.data, [isbnSource], CAT_FLD_SRC_BASE), isbnSourceDigits),

                            action: function()
                            {
                                let newISBN = convISBN(getFld(params.node.data, [isbnSource], CAT_FLD_SRC_BASE));
                                if (newISBN)
                                {
                                    setFld(params.node.data, [colId], newISBN, CAT_FLD_SRC_BASE);
                                    gridOptions.api.refreshCells(params.node);
                                }
                            }
                        };
                        menuItems.push("separator");
                        menuItems.push(menuItemAutofillISBN);
                    }

                    default:
                    {
                        if (params.column.colDef.editable)
                        {
                            let menuItemEdit =
                            {
                                name: "Edit",
                                action: function()
                                {
                                    let cellDetails =
                                    {
                                        rowIndex:   gridOptions.api.rowModel.rowsToDisplay.indexOf(params.node),
                                        colKey:     colId
                                    };
                                    gridOptions.api.startEditingCell(cellDetails);
                                }
                            }
                            menuItems.splice(0, 0, menuItemEdit);
                        }
                        break;
                    }
                }

                return menuItems;
            }

            // Synch the selected records
            function synchSelectedRecs()
            {
                gridOptions.api.getSelectedNodes().forEach(synchWithOpenlib);
            }

            // Synch the record associated with a grid node with openlib
            function synchWithOpenlib(gridNode)
            {
                let isbn = gridNode.data[CAT_FLD_ISBN13];
                if (isbn)
                {
                    $.ajax(
                    {
                        url: "https://openlibrary.org/api/books?bibkeys=" + isbn + "&jscmd=details&format=json",
                        dataType: "json",
                        success: function(queryRes)
                        {
                            let catRec = gridNode.data;

                            // Clear any existing openlib data for the record
                            setFld(catRec, [CAT_FLD_SRC_OPENLIB], {}, CAT_FLD_SRC_BASE);

                            let olRec = queryRes[isbn];
                            if (olRec && olRec[OLK_DETAILS])
                            {
                                // Process author data
                                let auths = [];
                                let olRecAuths = olRec[OLK_DETAILS][CAT_FLD_AUTHORS];
                                if (olRecAuths)
                                {
                                    for (let idx = 0; idx < olRecAuths.length; idx++)
                                    {
                                        let authNames = olRecAuths[idx][OLK_AUTHOR_NAME].split(" ");
                                        let openlibAuth = {};
                                        openlibAuth[CAT_FLD_AUTHOR_SURNAME] = authNames.length > 0 ? authNames.pop() : null;
                                        openlibAuth[CAT_FLD_AUTHOR_GIVEN_NAMES] = authNames;
                                        auths.push(openlibAuth);
                                    }
                                    setFld(catRec, [CAT_FLD_AUTHORS], auths, CAT_FLD_SRC_OPENLIB);
                                }

                                // Process dimensions, length and mass
                                let olDimStr = olRec[OLK_DETAILS][OLK_DIMENSIONS];
                                if (olDimStr)
                                {
                                    // Assume OL dimensions are in inches
                                    let dimComponents = olDimStr.split(new RegExp(/\s+x\s+|\s+/));
                                    let olHeight = parseFloat(dimComponents.shift()) * IN_TO_CM;
                                    let olWidth = parseFloat(dimComponents.shift()) * IN_TO_CM;
                                    let olThickness = parseFloat(dimComponents.shift()) * IN_TO_CM;
                                    setFld(catRec, [CAT_FLD_DIM, CAT_FLD_DIM_HEIGHT], olHeight, CAT_FLD_SRC_OPENLIB);
                                    setFld(catRec, [CAT_FLD_DIM, CAT_FLD_DIM_WIDTH], olWidth, CAT_FLD_SRC_OPENLIB);
                                    setFld(catRec, [CAT_FLD_DIM, CAT_FLD_DIM_THICKNESS], olThickness, CAT_FLD_SRC_OPENLIB);
                                }

                                setFld(catRec, [CAT_FLD_DIM, CAT_FLD_DIM_LENGTH], olRec[OLK_DETAILS][OLK_PAGES], CAT_FLD_SRC_OPENLIB);

                                let olMassStr = olRec[OLK_DETAILS][OLK_WEIGHT];
                                if (olMassStr)
                                {
                                    let olMassComponents = olMassStr.trim().split(new RegExp(/\s+/));
                                    let olMass = olMassComponents.shift();
                                    let olMassUnits = olMassComponents.length > 0 ? olMassComponents.shift() : null;
                                    if (!isNaN(olMass))
                                    {
                                        setFld(catRec, [CAT_FLD_DIM, CAT_FLD_DIM_MASS], parseFloat(olMass), CAT_FLD_SRC_OPENLIB);
                                    }
                                    setFld(catRec, [CAT_FLD_DIM, CAT_FLD_DIM_MASS_UNITS], olMassUnits, CAT_FLD_SRC_OPENLIB);
                                }

                                // Process miscellaneous details
                                let olSubkeys = [OLK_FORMAT, OLK_KEY, OLK_PUBLISHERS, OLK_PUBLISH_PLACES, OLK_PUBLISH_DATE, OLK_SUBTITLE, OLK_TITLE];
                                for (let idx = 0; idx < olSubkeys.length; idx++)
                                {
                                    subkey = olSubkeys[idx];
                                    setFld(catRec, [subkey], olRec[OLK_DETAILS][subkey], CAT_FLD_SRC_OPENLIB);
                                }

                                setFld(catRec, [OLK_URL], olRec[OLK_URL], CAT_FLD_SRC_OPENLIB);

                                // Mark the record as having an openlib equivalent
                                setFlag(catRec, BCK_FLAG_BIT_IN_OPENLIB);
                            }
                            else
                            {
                                clearFlag(catRec, BCK_FLAG_BIT_IN_OPENLIB);
                            }

                            // Mark the record as in synch
                            setFlag(catRec, BCK_FLAG_BIT_OPENLIB_SYNCED);

                            // Set the synch time
                            let synchTime = new Date();
                            let synchTimeString = formatAsDate(synchTime.getFullYear(),
                                                               synchTime.getMonth() + 1,
                                                               synchTime.getDate()) + " " +
                                                  synchTime.toTimeString();
                            setFld(catRec, [CAT_FLD_OPENLIB_SYNCH_TIME], synchTimeString, CAT_FLD_SRC_BASE);

                            gridOptions.api.refreshCells(gridNode);
                        }
                    });
                }
            }

            // Returns the minimum catalogue record ID
            function getMinRecId()
            {
                let minId = catData.length > 0 ? catData[0][CAT_FLD_ID] : 0;
                for (let idx = 0; idx < catData.length; idx++)
                {
                    minId = Math.min(minId, catData[idx][CAT_FLD_ID]);
                }
                return (minId);
            }

            // Returns the maximum grid index
            function getMaxGridIdx()
            {
                let gridRows = gridOptions.api.rowModel.rowsToDisplay;
                return gridRows.length > 0 ? gridRows.length - 1 : -1;
            }

            // Returns the maximum data array index
            function getMaxDataIdx()
            {
                return catData.length > 0 ? catData.length - 1 : -1;
            }

            // Returns the maximum catalogue record ID
            function getMaxRecId()
            {
                let maxId = 0;
                for (let idx = 0; idx < catData.length; idx++)
                {
                    maxId = Math.max(maxId, catData[idx][CAT_FLD_ID]);
                }
                return (maxId);
            }

            // Adds a catalogue record relative to the positions given in the
            // grid (i.e. the catalogue as displayed) and the underlying data.
            // Note that the grid insertion does not work as desired if sorting
            // on a field other than the ID has been applied.
            function addCatRec(gridRefIdx, dataRefIdx, recId, addAfterRefIdx = true)
            {
                // The grid/data positions where the new rcord will be added
                let gridAddIdx = addAfterRefIdx ? gridRefIdx + 1 : gridRefIdx;
                let dataAddIdx = addAfterRefIdx ? dataRefIdx + 1 : dataRefIdx;

                // Create new record with required ID
                let catRec = {};
                catRec[CAT_FLD_ID] = recId;

                // Add record to the underlying data array, and update IDs
                // of all following records
                catData.splice(dataAddIdx, 0, catRec);
                for (let idx = dataAddIdx + 1; idx < catData.length; idx++)
                {
                    catData[idx][CAT_FLD_ID]++;
                }

                // Synch changes with the grid's row data
                gridOptions.api.updateRowData({add: [catRec], addIndex: gridAddIdx});

                // Scroll to the added record
                gridOptions.api.ensureIndexVisible(gridAddIdx);
            }

            // Deletes the selected records
            function delSelectedRecs()
            {
                // Identify the rows in the grid and the underlying data array
                // elements to be deleted
                let delRows = gridOptions.api.getSelectedRows();
                let delDataIdxes = [];
                for (let idx = 0; idx < delRows.length; idx++)
                {
                    delDataIdxes.push(catData.indexOf(delRows[idx]));
                }
                delDataIdxes.sort();
                let minDelIdx = delDataIdxes.length > 0 ? delDataIdxes[0] : 0;

                // Delete selected records from the underlying data array.
                // This is done in descending index order, since deleting in
                // the other direction shifts the correspondence between
                // indexes and catalogue records and causes the wrong records
                // to be deleted. :)
                // TODO: implement batched deletion.
                for (let idx = delDataIdxes.length - 1; idx >= 0; idx--)
                {
                    let delDataIdx = delDataIdxes[idx];
                    catData = catData.slice(0, delDataIdx).concat(catData.slice(delDataIdx + 1));
                }

                // Ensure the IDs are contiguous.
                // Special handling of deletion of first record.
                if (minDelIdx == 0 && catData.length > 0)
                {
                    catData[0][CAT_FLD_ID]--;
                }

                for (let idx = 1; idx < catData.length; idx++)
                {
                    catData[idx][CAT_FLD_ID] = catData[idx-1][CAT_FLD_ID] + 1;
                }

                // Synch changes with the grid's row data
                gridOptions.api.updateRowData({remove: delRows});
            }

            // Function for comparing two catalogue records
            function compareRecs(catRec1, catRec2)
            {
                return (catRec1[CAT_FLD_ID] - catRec2[CAT_FLD_ID]);
            }

            // Identifies the catalogue data source
            function getDataSrc()
            {
                return ($("[name='optSrc']:checked").val());
            }

            // Checks if a catalogue record includes a field, which is
            // represented by a chain of keys,
            //  e.g. hasFld(catRec, ["openlib", "dimensions", "thickness"])
            //       returns true if catRec["openlib"]["dimensions"]["thickness"] exists
            function hasFld(catRec, keyChain)
            {
                for (let catRecLevel = 0; catRecLevel < keyChain.length; catRecLevel++)
                {
                    key = keyChain[catRecLevel]
                    if (!catRec || !(key in catRec))
                    {
                        return false;
                    }
                    catRec = catRec[key];
                }
                return true;
            }

            // Fetches a field from a catalogue record, assuming the data
            // source specified by the dataSrc parameter and returning a
            // default value if the field doesn't exist.
            // If the "combined" data source is selected, the function
            // checks each of the three data sources in turn for a non-null
            // field.
            function getFld(catRec, keyChain, dataSrc = getDataSrc(), defVal = null)
            {
                let fld = defVal;
                let dataSrcList = dataSrc == CAT_FLD_SRC_COMB ? [CAT_FLD_SRC_BASE, CAT_FLD_SRC_OPENLIB, CAT_FLD_SRC_AMAZON] : [dataSrc];
                while(dataSrcList.length > 0 && !fld)
                {
                    let fldSrc = dataSrcList.shift();
                    let fldKeyPrefix = (fldSrc == CAT_FLD_SRC_BASE) ? [] : [fldSrc];
                    let fldKeyChain = fldKeyPrefix.concat(keyChain);
                    if (hasFld(catRec, fldKeyChain))
                    {
                        // Recursive fetching of object properties...
                        let obj = catRec;
                        while (fldKeyChain.length > 0)
                        {
                            obj = obj[fldKeyChain.shift()];
                        }
                        fld = obj;
                    }
                }

                return fld;
            }

            // Sets a field value.
            // If the catalogue is currently viewed with combined data sources,
            // edits are directed to the base source.
            function setFld(catRec, keyChain, value, dataSrc = getDataSrc())
            {
                let dataDest = dataSrc == CAT_FLD_SRC_COMB ? CAT_FLD_SRC_BASE : dataSrc;

                let fldKeyChain = (dataDest == CAT_FLD_SRC_BASE) ? keyChain : [dataDest].concat(keyChain);
                let obj = catRec;
                let key = null;
                while (fldKeyChain.length > 1)
                {
                    key = fldKeyChain.shift();
                    if (!(key in obj))
                    {
                        // Initialise...
                        obj[key] = {};
                    }
                    obj = obj[key];
                }
                obj[fldKeyChain.shift()] = value;

                return true;
            }

            // Sets a flag
            function setFlag(catRec, flagPos)
            {
                let flags = getFld(catRec, [CAT_FLD_FLAGS], CAT_FLD_SRC_BASE, 0);
                flags |= (1 << flagPos);
                setFld(catRec, [CAT_FLD_FLAGS], flags, CAT_FLD_SRC_BASE);
            }

            // Clears a flag
            function clearFlag(catRec, flagPos)
            {
                let flags = getFld(catRec, [CAT_FLD_FLAGS], CAT_FLD_SRC_BASE, 0);
                flags |= ~(1 << flagPos);
                setFld(catRec, [CAT_FLD_FLAGS], flags, CAT_FLD_SRC_BASE);
            }

            // Checks if a flag is set
            function isFlagSet(catRec, flagPos)
            {
                return (getFld(catRec, [CAT_FLD_FLAGS], CAT_FLD_SRC_BASE, 0) & (1 << flagPos));
            }

            // Format a field as a currency string
            function formatAsCurrency(fldParams)
            {
                priceString = null;

                if (fldParams.value)
                {
                    priceString = Number.parseFloat(fldParams.value).toFixed(2);
                    currency = getFld(fldParams.data, [CAT_FLD_CURRENCY], CAT_FLD_SRC_BASE);
                    if (currency)
                    {
                        if (currency == "VND")
                        {
                            priceString += CURRENCY_SYMBOLS[currency];
                        }
                        else
                        {
                            priceString = CURRENCY_SYMBOLS[currency] + priceString;
                        }
                    }
                }

                return (priceString);
            }

            function formatAsMass(mass)
            {
                return (Number.parseFloat(mass).toFixed(3));
            }

            function getAuthorNames(params, nameType)
            {
                authData = getFld(params.data, [CAT_FLD_AUTHORS]);
                namesString = "";

                if (authData)
                {
                    for (authIdx = 0; authIdx < authData.length; authIdx++)
                    {
                        if (namesString)
                        {
                            namesString += AUTH_SEP + " ";
                        }
                        if (nameType == NameEnum.NAME_SUR)
                        {
                            if (CAT_FLD_AUTHOR_SURNAME in authData[authIdx])
                            {
                                namesString += authData[authIdx][CAT_FLD_AUTHOR_SURNAME];
                            }
                        }
                        else if (nameType == NameEnum.NAME_GIVEN)
                        {
                            if (CAT_FLD_AUTHOR_GIVEN_NAMES in authData[authIdx])
                            {
                                namesString += authData[authIdx][CAT_FLD_AUTHOR_GIVEN_NAMES].join(" ");
                            }
                        }
                    }
                }
                return namesString;
            }

            function setAuthorNames(params, nameType)
            {
                // Create a copy of the authors field to work with below
                authData = JSON.parse(JSON.stringify(getFld(params.data, [CAT_FLD_AUTHORS])));
                if (!authData)
                {
                    authData = [];
                }

                newNames = params.newValue ? (params.newValue.split(AUTH_SEP)).map(function(comp) {return String.prototype.trim.apply(comp);}) : [];

                for (authIdx = newNames.length; authIdx < authData.length; authIdx++)
                {
                    if (nameType == NameEnum.NAME_SUR)
                    {
                        delete(authData[authIdx][CAT_FLD_AUTHOR_SURNAME]);
                    }
                    else
                    {
                        delete(authData[authIdx][CAT_FLD_AUTHOR_GIVEN_NAMES]);
                    }
                }

                for (nameIdx = 0; nameIdx < newNames.length && nameIdx < authData.length; nameIdx++)
                {
                    if (nameType == NameEnum.NAME_SUR)
                    {
                        authData[nameIdx][CAT_FLD_AUTHOR_SURNAME] = newNames[nameIdx];
                    }
                    else
                    {
                        authData[nameIdx][CAT_FLD_AUTHOR_GIVEN_NAMES] = newNames[nameIdx].split();
                    }
                }

                for (; nameIdx < newNames.length; nameIdx++)
                {
                    newAuth = {};
                    if (nameType == NameEnum.NAME_SUR)
                    {
                        newAuth[CAT_FLD_AUTHOR_SURNAME] = newNames[nameIdx];
                        newAuth[CAT_FLD_AUTHOR_GIVEN_NAMES] = [];
                    }
                    else
                    {
                        newAuth[CAT_FLD_AUTHOR_SURNAME] = "";
                        newAuth[CAT_FLD_AUTHOR_GIVEN_NAMES] = newNames[nameIdx].split();
                    }
                    authData.push(newAuth);
                }

                /*
                for (authIdx = newNames.length; authIdx < authData.length; authIdx++)
                {
                    if (Object.keys(authData[authIdx]).length == 0)
                    {
                    }
                }
                */
                return setFld(params.data, [CAT_FLD_AUTHORS], authData);
            }

            // Checks if a candidate ISBN is valid, i.e. matches the relevant
            // pattern for the required number of digits
            function isISBNValid(isbnCandidate, requiredDigits)
            {
                let valid = false;
                if (requiredDigits == ISBN10_DIGITS || requiredDigits == ISBN13_DIGITS)
                {
                    let isbnRegexMatch = requiredDigits == ISBN10_DIGITS ? REGEX_ISBN10.test(isbnCandidate) : REGEX_ISBN13.test(isbnCandidate);
                    valid = isbnRegexMatch && (calcISBNCheckDigit(isbnCandidate) == isbnCandidate[isbnCandidate.length - 1]);
                }
                return valid;
            }

            // Computes the expected check digit for a candidate ISBN, using
            // steps described at https://bisg.org/page/conversionscalculat
            function calcISBNCheckDigit(isbnCandidate)
            {
                let checkDigit = -1;  // Initialise to an invalid digit
                if (REGEX_ISBN10.test(isbnCandidate))
                {
                    checkDigit = 0;
                    for (let idx = 0; idx < ISBN10_DIGITS - 1; idx++)
                    {
                        checkDigit += (ISBN10_MAX_DIGIT_WEIGHT - idx) * parseInt(isbnCandidate[idx]);
                    }
                    checkDigit %= ISBN10_MOD_FACTOR;
                    if (checkDigit > 0)
                    {
                        checkDigit = ISBN10_MOD_FACTOR - checkDigit;
                    }
                    return checkDigit < 10 ? checkDigit.toString() : "X";
                }
                else if (REGEX_ISBN13.test(isbnCandidate))
                {
                    checkDigit = 0
                    for (let idx = 0; idx < ISBN13_DIGITS - 1; idx++)
                    {
                        if (idx % 2 == 0)
                        {
                            checkDigit += parseInt(isbnCandidate[idx]);
                        }
                        else
                        {
                            checkDigit += 3 * parseInt(isbnCandidate[idx]);
                        }
                    }
                    checkDigit = ISBN13_MOD_FACTOR - checkDigit % ISBN13_MOD_FACTOR;
                    return checkDigit < 10 ? checkDigit.toString() : "0";
                }
                return checkDigit.toString();
            }

            // Converts between ISBN formats
            function convISBN(isbn)
            {
                let isbnConv = null;
                if (REGEX_ISBN10.test(isbn) || REGEX_ISBN13.test(isbn))
                {
                    if (REGEX_ISBN10.test(isbn))
                    {
                        isbnConv = ISBN13_PREFIX + isbn;
                    }
                    else if (REGEX_ISBN13.test(isbn))
                    {
                        isbnConv = isbn.replace(ISBN13_PREFIX, "");
                    }
                    isbnConv = isbnConv.substr(0, isbnConv.length - 1) + calcISBNCheckDigit(isbnConv);
                }
                return isbnConv;
            }

            // Format a year, month and day as a date string
            function formatAsDate(year, month, day)
            {
                let dateString = "";
                if (year)
                {
                    dateString = year.toString();
                    if (month)
                    {
                        dateString += DATE_SEP + (month < 10 ? "0" : "") + month.toString();

                        if (day)
                        {
                            dateString += DATE_SEP + (day < 10 ? "0": "") + day.toString();
                        }
                    }
                }
                return dateString;
            }

            // Checks if a date (specified as year, month, day values) is valid
            function isDateValid(year, month, day)
            {
                let valid = true;
                if (year)
                {
                    valid = (year >= YEAR_MIN);
                    if (valid && month)
                    {
                        valid = (month >= MONTH_MIN && month <= MONTH_MAX);
                        if (valid && day)
                        {
                            let day_max = STD_MONTH_LENGTHS[month];
                            // Special handling for February... bloody February
                            if (month == 2 &&
                               (year % 400 == 0 ||
                               (year % 4 == 0 && year % 100 != 0)))
                            {
                                day_max = FEB_LEAP_YEAR_DAYS;
                            }

                            valid = day <= day_max;
                        }
                    }
                }
                return valid;
            }

            // Sets a date field
            function setDateFld(fldParams, keyChain)
            {
                dateString = fldParams.newValue;
                if (dateString)
                {
                    dateComponents = dateString.split(DATE_SEP);
                    if (dateComponents.length > 0 && dateComponents.length <= 3)
                    {
                        yearString  = dateComponents.shift();
                        monthString = dateComponents.length > 0 ? dateComponents.shift() : null;
                        dayString   = dateComponents.length > 0 ? dateComponents.shift() : null;

                        year    = (yearString && REGEX_YEAR.test(yearString)) ? parseInt(yearString) : null;
                        month   = (monthString && REGEX_MONTH.test(monthString)) ? parseInt(monthString) : null;
                        day     = (dayString && REGEX_DAY.test(dayString)) ? parseInt(dayString) : null;

                        setFld(fldParams.data, keyChain.concat([CAT_FLD_DATE_YEAR]), year, CAT_FLD_SRC_BASE);
                        setFld(fldParams.data, keyChain.concat([CAT_FLD_DATE_MONTH]), month, CAT_FLD_SRC_BASE);
                        setFld(fldParams.data, keyChain.concat([CAT_FLD_DATE_DAY]), day, CAT_FLD_SRC_BASE);
                    }
                }
                else
                {
                    setFld(fldParams.data, keyChain, null, CAT_FLD_SRC_BASE);
                }
            }

            function renderDateFld(fldParams)
            {
                let dateObj = fldParams.value;
                if (dateObj)
                {
                    let cellString = formatAsDate(dateObj[CAT_FLD_DATE_YEAR],
                                                  dateObj[CAT_FLD_DATE_MONTH],
                                                  dateObj[CAT_FLD_DATE_DAY]);
                    return markFldValidity(fldParams, cellString);
                }
            }

            // Compares a reference date (formatted as a JS Date object) with a
            // record field date (formatted with day/month/year components)
            function compareDates(refDate, recFld)
            {
                let recFldYear  = recFld[CAT_FLD_DATE_YEAR];
                let recFldMonth = recFld[CAT_FLD_DATE_MONTH];
                let recFldDay   = recFld[CAT_FLD_DATE_DAY];
                let recFldDate  = new Date(recFldYear,
                                           recFldMonth ? recFldMonth - 1 : 0,
                                           recFldDay ? recFldDay : 1);

                if (recFldDate.getTime() === refDate.getTime())
                {
                    return 0;
                }

                if (recFldDate < refDate)
                {
                    return -1;
                }

                return 1;
            }

            // Checks if a given catalogue record field's contents are valid:
            // validation steps depend on the field's expected data type, etc.
            function isFldValid(fldParams)
            {
                let valid = true;
                let fldHdr = fldParams.colDef.headerName;
                switch (fldHdr)
                {
                    case COL_HDR_ISBN_13:
                    case COL_HDR_ISBN_10:
                        let isbnCandidate = fldParams.value;
                        if (isbnCandidate)
                        {
                            // The ISBN field must match the relevant pattern
                            // and have a sensible check digit
                            let requiredDigits = fldHdr == COL_HDR_ISBN_13 ? ISBN13_DIGITS : ISBN10_DIGITS;
                            valid = isISBNValid(isbnCandidate, requiredDigits);
                        }
                        break;

                    case COL_HDR_PURCH_DATE:
                    case COL_HDR_ARR_DATE:
                        let dateCandidate = fldParams.value;
                        if (dateCandidate)
                        {
                            valid = isDateValid(dateCandidate[CAT_FLD_DATE_YEAR],
                                                dateCandidate[CAT_FLD_DATE_MONTH],
                                                dateCandidate[CAT_FLD_DATE_DAY]);
                        }
                        break;

                    case COL_HDR_PURCH_PRICE:
                    case CAT_FLD_SHIP_PRICE:
                        let priceCandidate = fldParams.value;
                        if (priceCandidate)
                        {
                            valid = !isNaN(priceCandidate);
                        }

                    default:
                }

                return valid;
            }

            function markFldValidity(fldParams, cellString)
            {
                return isFldValid(fldParams) ? cellString : "<span class='invalid-data'>" + cellString + "</span>";
            }

            //document.getElementById('testDiv').innerHTML = CURRENCY_SYMBOLS['AUD'];
        </script>
    </body>
</html>
